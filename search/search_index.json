{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Google Developer Groups (GDG) \u2014 IAU \u2014 Game Development Bootcamp","text":""},{"location":"#welcome-to-the-gdg-game-development-bootcamp","title":"Welcome to the GDG Game Development Bootcamp!","text":"<p>Welcome to the Game Development Bootcamp of the Google Developer Groups (GDG) club at the Imam Abdulrahman Bin Faisal University (IAU). Our main focus here is to train and prepare students to develop their own games, and help kick-off their career in game development.</p>"},{"location":"#about-us","title":"About Us","text":"<p>We're a group of passionate game developers eager to help others learn more about the wonders of game development and help develop their knowledge and skills. We try to create educational content that's fitting for both experienced developers and novices. Whether you're a seasoned expert of game development, or just starting your journey, there's a place for you here.</p>"},{"location":"#what-to-expect","title":"What To Expect","text":"<p>We have created a 4 week course for aspiring game developers of the club to participate in. Each week will focus on a set of game development concepts and will have tutorials and live sessions to help develop the students skills. In addition to the general course, a group of students within the club will be specially selected to partake in \"focus group\" teams that will receive direct mentorship from the track's leaders and assistance in creating a demo for their own, unique game.</p>"},{"location":"#the-plan","title":"The Plan","text":"<p>The course will last for 4 weeks. Each week will cover certain concepts, have live-coding sessions, and tasks for students to complete.</p>"},{"location":"#week-1-introduction-to-game-programming","title":"Week 1 - Introduction to Game Programming","text":"<p>Key Concepts</p> <ul> <li> <p>What is a game?</p> </li> <li> <p>What is a video game?</p> </li> <li> <p>How do video games really work?</p> </li> <li> <p>Understand the game loop.</p> </li> <li> <p>Understanding coordinate systems and other basic game math concepts.</p> </li> <li> <p>How to use delta time to ensure consistent physics.</p> </li> <li> <p>Make Pong using Raylib and C++ as an introduction to game programming.</p> </li> </ul> <p>Tasks</p> <ul> <li>Recreate Pong following the tutorial, and add certain basic functions to it.</li> </ul>"},{"location":"#week-2-introduction-to-game-engines-and-godot","title":"Week 2 - Introduction to Game Engines and Godot","text":"<p>Key Concepts</p> <ul> <li> <p>What is a game engine?</p> </li> <li> <p>Basic game engine concepts.</p> </li> <li> <p>What is Godot?</p> </li> <li> <p>Understanding nodes, scenes, and scripts.</p> </li> <li> <p>Using nodes and scripts to make a moving square.</p> </li> <li> <p>Understanding input maps.</p> </li> <li> <p>Understanding collision layers/masks, and movement functions.</p> </li> <li> <p>Using autoloads and signals.</p> </li> <li> <p>Making Pong again in Godot.</p> </li> </ul> <p>Tasks</p> <ul> <li>Make Pong following the tutorial again and make certain adjustments to it.</li> </ul>"},{"location":"#week-3-making-a-2d-platformer-in-godot","title":"Week 3 - Making a 2D Platformer in Godot","text":"<p>Key Concepts:</p> <ul> <li> <p>How to import assets to your Godot project.</p> </li> <li> <p>Understanding tilemaps.</p> </li> <li> <p>Understanding 2D animations and spritesheets.</p> </li> <li> <p>How to write scripts for 2D Platformers.</p> </li> <li> <p>Making a camera that follows the player.</p> </li> <li> <p>Making a simple 2D platformer with levels and progression.</p> </li> <li> <p>How to export a game in Godot.</p> </li> </ul> <p>Tasks</p> <ul> <li>Make a 2D platformer following the tutorial and add certain features and mechanics.</li> </ul>"},{"location":"#week-4-making-a-top-down-survival-game-in-godot","title":"Week 4 - Making a Top-Down Survival Game in Godot","text":"<p>Key Concepts</p> <ul> <li> <p>How to make a game in the top-down plane.</p> </li> <li> <p>Making simple AI for enemies.</p> </li> <li> <p>Making a wave-based enemy system.</p> </li> <li> <p>Creating an item-generation system.</p> </li> <li> <p>Making a menu and UI for the game.</p> </li> </ul> <p>Tasks</p> <ul> <li>Follow the tutorial and add certain mechanics.</li> </ul>"},{"location":"Week-1.-Making-Your-First-Game/","title":"Introduction","text":""},{"location":"Week-1.-Making-Your-First-Game/#welcome","title":"Welcome!","text":"<p>Welcome to the first week of the game development track! In this week, we will discuss the bare basics of game development. Starting from just the simple definition of a game, moving onto the reality of how video games actually work, and finally making our own first game to top it off.</p>"},{"location":"Week-1.-Making-Your-First-Game/#what-is-a-game","title":"What is a game?","text":"<p>Most of us have a pretty intuitive notion of a game, right? The word \"game\" can include games such as Monopoly or Chess.</p> <p>We can say that a game is a structured activity where players can make decisions and take actions within the rules of a game to achieve a specified goal, and they can either win or lose in doing that.</p> <p>When it comes to video games however, we typically think of virtual worlds. With many characters, objects, and environments. And this is true. Despite this however, a video game is still a game, and the same principles of ordinary games apply.</p> <p>There are many different types of games. They are classified by genres, and often along the gameplay style, rules, themes, and other elements.</p> <p></p>"},{"location":"Week-1.-Making-Your-First-Game/#video-games","title":"Video Games","text":"<p>Video games - as software - all have some common components to them. Almost every game has, at least some of:</p> <ul> <li> <p>A Graphics System: Responsible for displaying graphics to the screen.</p> </li> <li> <p>An Audio System: Responsible for audio and playing sounds of the game.</p> </li> <li> <p>A Physics System: Responsible for physics of players and objects.</p> </li> <li> <p>An Input System: Takes in the input of the player (keyboards, controllers, etc...)</p> </li> <li> <p>Game Logic: A logic and set of rules dictating the state of the game and what the player can and cannot do, and how the game state responds to player input.</p> </li> <li> <p>Many Other Components...</p> </li> </ul> <p>When we look at all these technical components that make up a video game, they are plentiful, but they all work together to create one, coherent experience for the player. Thus we can say that video games are the interplay of many technical components, to produce a player experience with rules and constraints that can be won or lost.</p> <p></p>"},{"location":"Week-1.-Making-Your-First-Game/#the-game-loop","title":"The Game Loop","text":"<p>We mentioned that video games are comprised of many technical components. All of these components are updated in a fixed \"loop\" throughout the entirety of the game, called the \"game loop\".</p> <p></p> <p>The game loop first processes player input (such as from the keyboard, mouse movements, or buttons pressed on a controller), then updates the game state based on this input and other variables, finally it draws (renders) this state visually to the screen. This process repeats itself ad infinitum (forever) until the game ends.</p> <p>Example Game Loop Code</p> <pre><code>int main()\n{\n\u00a0\u00a0\u00a0\u00a0// Initializing the technical components / subsystems\n\u00a0\u00a0\u00a0\u00a0InitGame();\n\n\u00a0\u00a0\u00a0\u00a0// The game loop, it repeats continuously until the game ends\n\u00a0\u00a0\u00a0\u00a0while (GameIsRunning)\n\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0// ====== NEW FRAME ======\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Operating system work is done here\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Receiving input from keyboard-mouse-controller\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// And checking OS events (did the window close? or minimize? etc)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Not the subject of our focus for this track\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ProcessInput();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// The actual game's state\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// (players position and health, enemies, inventory, etc...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// is updated here\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0UpdateGame();\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// The game's state is rendered (drawn) to the screen graphically here\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0RenderGame();\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// ====== END OF FRAME ======\n\u00a0\u00a0\u00a0\u00a0}\n\n\u00a0\u00a0\u00a0\u00a0// We exitted the loop (GameIsRunning == false)\n\u00a0\u00a0\u00a0\u00a0// Quit the game\n\u00a0\u00a0\u00a0\u00a0ExitGame()\n}\n</code></pre> <p>Effectively, all video games run in one big <code>while</code> loop. The number of times a loop is completed in one second is called the \"frames per second\" (FPS) of a game. \"Frame\" refers to the visual output of the game to the screen, the final step of the loop before repeating. Generally, a higher FPS means a smoother experience for the player.</p>"},{"location":"Week-1.-Making-Your-First-Game/#pong","title":"Pong","text":"<p>Pong is the first video game ever made, it's basically an extremely simple top-down tennis of sorts. Here is some footage of the gameplay and an example of what the game's loop would look like.</p> <p></p> <p>Example Pong Game Code</p> <pre><code>while (GameIsRunning)\n{\n    // ===== NEW FRAME =====\n\n    ProcessInput();\n\n    if (QuitButtonPressed())\n    {\n        GameIsRunning = false;\n    }\n\n    MovePaddles();\n\n    MoveBall();\n\n    CheckBallCollisionsAndBounce();\n\n    if (BallImpactedSide(LEFT_PLAYER))\n    {\n        IncrementScore(RIGHT_PLAYER);\n        ResetBall();\n    }\n    if (BallImpactedSide(RIGHT_PLAYER))\n    {\n        IncrementScore(LEFT_PLAYER);\n        ResetBall();\n    }\n\n    RenderPlayfield();\n\n    // ===== END OF FRAME =====\n}\n</code></pre> <p>On a more granular level, this is an example of what each frame of the game would look like as it's being updated. Remember that \"update\" here just means that we're repeating this loop once again.</p> <p></p>"},{"location":"Week-1.-Making-Your-First-Game/#making-our-own-game","title":"Making our Own Game","text":"<p>Don't worry if you don't understand all of this just yet. In the next section of this week, we will get started on actually trying to create pong for ourselves using Raylib and C++. If you don't understand anything about the example code for Pong, you'll understand it soon enough when you follow the tutorial.</p> <p>The important thing to take away from this section is this:</p> <ul> <li> <p>Video games run in a fixed loop, called the game loop</p> </li> <li> <p>This loop updates the state of the game, and draws it to the screen graphically, then repeats that process until the game is over</p> </li> <li> <p>The game is comprised of many technical components, all of which are updated in the loop and play a role in completing the game experience for the player</p> </li> </ul>"},{"location":"Week-1.-Making-Your-First-Game/1-Setting-Up/","title":"1. Getting Started","text":"<p>This is the setup section of the tutorial. The final setups for Windows and MacOS are provided on Github and you can fork and clone them to get started immediately.</p> <p>This page explains how the setup works, for people who are curious or are facing some errors.</p> <p>This page will cover the setup for the Windows version only.</p>"},{"location":"Week-1.-Making-Your-First-Game/1-Setting-Up/#making-the-build-system","title":"Making the Build System","text":"<p>To get started, let's make a folder called \"Pong\", and create a file in it called \"pong.cpp\". The \".cpp\" file extension stands for C++.</p> <p></p> <p>Inside the file we'll just put a hello world program for now.</p> <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    std::cout &lt;&lt; \"Hello World\\n\";\n    return 0;\n}\n</code></pre> <p>One way to actually run this code is to use the standard C/C++ VSCode extension, in this tutorial however, we'll be invoking the compiler directly in the command-line. Make sure you have the GCC compiler installed on your device, and in your path (resources will be provided for this later). Open CMD (or whichever terminal you prefer), go to the folder we just created, and write <code>g++ pong.cpp -o pong.exe</code>.</p> <p></p> <p>This will invoke the G++ compiler, compile the file <code>pong.cpp</code> and link it into the output executable <code>pong.exe</code>. There should now be a <code>pong.exe</code> file in our new folder.</p> <p></p> <p>If you run it from the CMD by just typing <code>pong.exe</code>, it will run our Hello World program.</p> <p></p> <p>Having to write out the compile command everytime we want to compile is tiresome though, so instead of doing that we will write a shell script that will just execute the command for us. In our new folder, let's create a file called <code>build.bat</code>.</p> <p></p> <p>This is the file that contains our compile command, for now let's just put the command we used earlier on it.</p> <pre><code>g++ pong.cpp -o pong.exe\n</code></pre> <p>If we just call this script now in our terminal, it will automatically type out the command written inside it.</p> <p></p> <p>The second line is typed out automatically. If you don't want for it to be visible however, just type out a <code>@</code> in the beginning of the line where your command is.</p> <pre><code>@g++ pong.cpp -o pong.exe\n</code></pre> <p>Now, it should just execute the compile command without echoing it in the terminal.</p> <p></p> <p>To verify that it's working, let's add a message in our program, build it, then run it to check that it is indeed working correctly.</p> <pre><code>    std::cout &lt;&lt; \"Hello World\\n\";\n    std::cout &lt;&lt; \"This is our first game in GDG!\\n\";\n</code></pre> <p>Let's save it and check.</p> <p></p> <p>Now let's setup Raylib for this project. The process is as simple as adding a couple of flags to our <code>build.bat</code> file, and copying a few files to our Pong folder.</p>"},{"location":"Week-1.-Making-Your-First-Game/1-Setting-Up/#setting-up-raylib","title":"Setting up Raylib","text":"<p>In order to setup Raylib, there are really only 2 things we need to do:</p> <ul> <li> <p>Add a header folder and file, and include them in the compile command</p> </li> <li> <p>Add the actual library itself and link it in the compile command</p> </li> </ul> <p>In total, they're just 2 files, 1 library and 1 header. There will be a link to download these files. Just copy them in your folder like so:</p> <p></p> <p>Now, let's update our build script to account for these inclusions.</p> <pre><code>@g++ pong.cpp -o pong.exe -I include\n</code></pre> <p>Now, if we update our main source file to include <code>raylib.h</code>, it should work fine once we compile it.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;raylib.h&gt;\n</code></pre> <p>Let's compile.</p> <p></p> <p>Great! There are no errors. Here's what we would've got if we didn't put <code>-I include</code> in our build file:</p> <p></p> <p>The <code>-I include</code> command basically tells the compiler to search within the provided directory for header files, in this case it's searching through our \"include\" folder to find <code>raylib.h</code>.</p> <p>Now, let's try to actually call a method found in <code>raylib.h</code> in our file. Let's use the most simple method, <code>InitWindow()</code>. As you might expect, this is just a function that creates a window for our game. It takes in three parameters: <code>width</code>, <code>height</code>, and <code>title</code>. For our purposes, we'll make our game a fixed 1280x720 and call it \"pong\".</p> <pre><code>    std::cout &lt;&lt; \"Hello World\\n\";\n    std::cout &lt;&lt; \"This is our first game in GDG!\\n\";\n    InitWindow(1280, 720, \"Pong\");\n</code></pre> <p>If we try to run the code now however, we'll get some strange errors:</p> <p></p> <p>This is GNU's idea of a linker error. It's long and protracted but basically, what it's trying to tell is us is that the <code>InitWindow()</code> function we're trying to call doesn't actually have an implementation available to it that it can execute. G++ knows the function exists because it's found in <code>raylib.h</code>, but it doesn't know what it actually does because the header file doesn't contain the implementation for the function. Instead, the implementation is available to us in the \"lib\" folder we downloaded from earlier.</p> <p></p> <p>In here we'll find this <code>libraylib.a</code> file.</p> <p></p> <p>This file contains the implementations of all the functions found in <code>raylib.h</code>, what we need to do now is to link it in our compile command:</p> <pre><code>@g++ pong.cpp -o pong.exe -I include -L lib -l raylib\n</code></pre> <p>The <code>-L lib</code> flag is similar to the <code>-I</code> one, it tells the compiler the directory to search through when looking for libraries to link, in this case it's the \"lib\" directory. The <code>-l raylib</code> flag tells the compiler to link the <code>libraylib.a</code> file inside the lib folder from earlier, the first 3 letters \"lib\" and the file extension \".a\" are not included when invoking this flag for some reason (GNU is weird).</p> <p>Let's try running it now:</p> <p></p> <p>Woah! Now that is a lot of linker errors. Don't fret though. All of these linker errors is because we didn't link the libraries of the actual operating system yet. You see, <code>InitWindow()</code> creates a window for our game to run in, in order for it to do that though, it needs to work with the operating system for it to actually get that window. In our case, the operating system is Windows, and there are actually a few Windows libraries we need to link before we can say that all the necessary libraries are linked to our program. So let's go ahead and include them.</p> <pre><code>@g++ pong.cpp -o pong.exe -I include -L lib -l raylib -l gdi32 -l opengl32 -l winmm\n</code></pre> <p>Now that's quite a lot of libraries. You don't need to know the details, but if you're curious, the libraries we linked are:</p> <ul> <li> <p><code>gdi32</code>: The Windows Graphics Device Interface, for creating our window</p> </li> <li> <p><code>opengl32</code>: The Open Graphics Library, for rendering our graphics</p> </li> <li> <p><code>winmm</code>: The Windows MultiMedia API, for audio stuff</p> </li> </ul> <p>Now, if we try to build, it should work just fine.</p> <p></p> <p>It works! However, if we try running it, something odd happens.</p> <p></p> <p>A bunch of Raylib Info lines show up, and a window momentarily appears and disappears, why does this happen? It's because after we Initialize our Window, there's nothing else left for the program to do, so it just shuts down.</p> <p>Don't worry about that for now. Right now, we've completed the setup section! Now we can move on to actually programming the game.</p>"},{"location":"Week-1.-Making-Your-First-Game/2-The-Game-Loop/","title":"2. The Game Loop","text":"<p>In the previous section of this tutorial, we setup our projects dependencies and build \"system\". Now, we'll actually get to programming the game itself, starting with the game loop.</p>"},{"location":"Week-1.-Making-Your-First-Game/2-The-Game-Loop/#the-game-loop","title":"The Game Loop","text":"<p>In our earlier sections, we discussed the basic idea of the game loop. Now we get to see what that looks like in code. Once we remove our <code>std::cout</code> lines, this is what our code looks like now:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;raylib.h&gt;\n\nint main()\n{\n    InitWindow(1280, 720, \"Pong\");\n    return 0;\n}\n</code></pre> <p>We can see that after the <code>InitWindow</code> call, there's no other code to execute, and the program returns. In order to stop this and actually have a program running, we need to create a loop. Theoretically, a <code>while (true)</code> loop could suffice, however in Raylib, there's a function called <code>WindowShouldClose()</code> that returns a boolean. We'll use this boolean as the condition for our loop instead, such that if the return value is <code>false</code>, then we know that nothing has been done to make the window close, and our program should continue executing.</p> <pre><code>    InitWindow(1280, 720, \"Pong\");\n\n    while (!WindowShouldClose())\n    {\n    }\n</code></pre> <p>The difference between this approach and the <code>while (true)</code> one is that for this one, certain events can take place that will actually effect the condition. For example, if we press the big red \"X\" on the top right corner of the window, this variable will switch to true, and our program will close. Another condition that will by default effect this variable is if we press the escape key. Pressing escape will shutdown our program by default.</p> <p>If we try to run it now, we get a window! However, it's unresponsive.</p> <p></p> <p>The reason for this is that throughout the loop that's repeating itself, our program is not interacting with the operating system at all. Raylib provides functions that do this directly, such as <code>PollInputEvents()</code>, this is for advanced users however. In Raylib, the polling of OS events happens in tandem with the rendering functions, so if we just create a simple rendering loop this problem will resolve itself just fine.</p>"},{"location":"Week-1.-Making-Your-First-Game/2-The-Game-Loop/#rendering-graphics","title":"Rendering Graphics","text":"<p>The graphics functions mostly operate in their own \"phase\" of sorts. The beginning and end of this phase are marked by the <code>BeginDrawing()</code> and <code>EndDrawing()</code> functions. If we place them in order in our loop, our program will become responsive.</p> <pre><code>    while (!WindowShouldClose())\n    {\n        BeginDrawing();\n        // All of our graphics stuff happens here!\n        EndDrawing();\n    }\n</code></pre> <p>If we run it now, we'll get this:</p> <p></p> <p>We finally have a fully working, proper, honest window on our hands. We can move it around, minimize it, and even close it. One thing we can't do yet is resize it, but that's intentional, to make the process of actually making our game simpler.</p> <p>Let's try actually drawing something on the screen for real this time. In Raylib, there's a function called <code>DrawRectangle()</code> that takes in 5 arguments. <code>posX, posY, width, height, color</code>. In both Raylib and Godot, the origin of a rectangle is the top-left corner, and the rectangle expands rightwards and downwards according to the width and height.</p> <p></p> <p>So, in our code, let's just a draw a red square with the origin points (0, 0) and a 40x40 size.</p> <pre><code>    while (!WindowShouldClose())\n    {\n        BeginDrawing();\n        DrawRectangle(0, 0, 40, 40, RED);\n        EndDrawing();\n    }\n</code></pre> <p>If we run it now, we'll see a red square at the top left corner of our screen:</p> <p></p> <p>The reason the square is showing up on the top left corner of the screen is because right now, the origin of the coordinate system is mapped to the top-left corner. This would be a good time to talk about coordinate systems.</p>"},{"location":"Week-1.-Making-Your-First-Game/2-The-Game-Loop/#coordinate-systems","title":"Coordinate Systems","text":"<p>Maths are a very common element of video game programming that you need to intuitively understand if you want to confidently develop your ideas into games. The maths required in game development is not that difficult or complicated, and in general you'll find you'll get better at it the more you do it.</p> <p>The first thing you should understand is coordinate systems. You might be familiar with this setup:</p> <p>You should all be familiar with this from high school. You have an X-axis and a Y-axis. The grid here represents all the points that you can represent in two-dimensions. Each square being one unit, right is positive on the X-axis, left is negative... basically no different from when you remember it.</p> <p>Well, no. Actually there is one difference between the systems in Raylib and Godot and from the coordinate systems you're all familiar with. In Raylib and Godot, up is negative on the Y-axis, and down is positive. So if we filled out the numbers it would look something like this.</p> <p>Moreover, the origin point (0, 0) is in the center. But in our current setup (in-game), the origin point is in the top left, and the width and height of the grid correspond to the screen width and height that we set. In other words, each unit in the grid is 1 pixel.</p> <p></p> <p>In this illustration, each grid square is obviously not one pixel because it's not scaled correctly, but this is just an example. When you look at it, and keeping in mind that rectangle coordinate systems follow the same pattern of having the origin at the top-left, it becomes clear why our call to the <code>DrawRectangle()</code> function caused it to appear where it did. (0, 0) is the top-left, and the square itself is goes 40 pixels to the right and 40 pixels down from the origin. If we stretched the width to 1280, same as the screen width, then it will appear as a big red strip on covering the top-most part of our screen.</p> <pre><code>        DrawRectangle(0, 0, 1280, 40, RED);\n</code></pre> <p></p> <p>Same with the height.</p> <pre><code>        DrawRectangle(0, 0, 40, 720, RED);\n</code></pre> <p></p> <p>Let's try placing the square right in the center of our screen. We know the right side is 1280, and the left side is 0, so logically the middle is between those two points , \\({(0+1280)\\over{2}}=640\\). Likewise with the height, \\({(0+720)\\over{2}}=360\\). So lets try placing our 40x40 square there.</p> <pre><code>        DrawRectangle(640, 360, 40, 40, RED);\n</code></pre> <p></p> <p>And there it is! You'll notice that it's not exactly in the center, rather, the top-left corner of the square is in the center. If we want the center of the square to be in the center of the screen we'd have to displace it up and to the left 20 units. But that's not necessary, what's important now is that you understand this concept of the coordinate system because it'll be really important for your game development journey.</p>"},{"location":"Week-1.-Making-Your-First-Game/2-The-Game-Loop/#moving-the-square","title":"Moving the Square","text":"<p>Having a square appear where we want it to be is cool and all, but it'd be nicer if we could actually move the square. Moving the square is really as simple as just moving the position of the square <code>posX, posY</code>. But how do we actually do that? Well first, we must take input from the user.</p> <p>Raylib has several functions for receiving input from the user, but the ones we're interested in right now are <code>IsKeyPressed()</code> <code>IsKeyDown()</code> and <code>IsKeyReleased()</code>. Each of these functions takes in a keycode as an argument, and returns a boolean.</p> <ul> <li> <p><code>IsKeyPressed()</code> returns true if the key was just pressed at that moment.</p> </li> <li> <p><code>IsKeyDown()</code> returns true if the key is held down at any moment.</p> </li> <li> <p><code>IsKeyReleased()</code>returns true if the key was just released at that moment.</p> </li> </ul> <p>Note</p> <p>In Godot \u2014 the engine we'll be using \u2014 the functions for checking input are mostly the same; there are distinctions between having just pressed a key, holding a key down, and having just released a key.</p> <p>Let's write something simple for now, let's make a program that changes the color of our square to green if the user pressed the space bar:</p> <pre><code>    Color square_color = RED;\n\n    while (!WindowShouldClose())\n    {\n        if (IsKeyPressed(KEY_SPACE))\n        {\n            square_color = GREEN;\n        }\n\n        BeginDrawing();\n        DrawRectangle(640, 360, 40, 40, square_color);\n        EndDrawing();\n    }\n</code></pre> <p>If we run the program now, the color of the square will be initially red:</p> <p></p> <p>But if we press space...</p> <p></p> <p>It turns green! This is the first example you'll see of non-graphics state being rendered in visual form. The <code>square_color</code> variable is affected by user input, and it's also used in the drawing phase of our program. If we want our square to move according to user input, we need to do something similar but this time with the player's position.</p> <pre><code>    Vector2 player_position = { 640, 360 };\n\n    while (!WindowShouldClose())\n    {\n        if (IsKeyPressed(KEY_RIGHT))\n        {\n            player_position.x += 40;\n        }\n\n        BeginDrawing();\n        DrawRectangle(player_position.x, player_position.y, 40, 40, RED);\n        EndDrawing();\n    }\n</code></pre> <p>What we've done here is used a <code>Vector2</code> struct, which is just a container for 2 floats <code>x</code> and <code>y</code>, to represent the player's position. We're then taking the right arrow key being pressed (KEY_RIGHT) as a sign to move the player 40 units to the right. Finally, in the <code>DrawRectangle()</code> call, we're substituting our initial constant values (640, 360) for the <code>player_position</code> variable. If all goes well, when we press the right arrow key, the player should move to the right.</p> About Vectors... <p>In game programming, the idea of a \"vector\" is quite versatile. From a sheer programming perspective, it's just a container for floats representing coordinates in a certain space, they can be two coordinates <code>x</code> and <code>y</code>, denoting a <code>Vector2</code>. Or they can be three coordinates, <code>x</code>, <code>y</code> and <code>z</code>, denoting a <code>Vector3</code>. In practice however, a vector can represent many things, they are most commonly used to represent points in a space, or an actual direction and magnitude in the conventional physics definition of a vector.</p> <p>Both concepts are used extensively in game programming, and are both represented with the same data type, <code>Vector</code>. To learn more about this topic, we recommend following this YouTube series on math for game developers. It's highly accessible and valuable.</p> <p></p> <p>Well, that's strange! The square seems to have stretched 40 units to the right and has become a rectangle. Did we make a mistake? No. Well, not in the state code anyways. </p> <p>You see, when rendering graphics, we need to make sure we're rendering the current state exclusively, and not the previous frames' state. In here, we have the state before we pressed right, and the state after pressing the right arrow key. Because we're not clearing the screen of the original state's visual output, the new visual output and old ones have been merged together. A combination of Frame 1 + Frame 2. The current order of rendering looks like this:</p> <ul> <li> <p>Draw red square at <code>(640, 360)</code></p> </li> <li> <p>Present to the screen</p> </li> <li> <p>== NEW FRAME ==</p> </li> <li> <p>Draw red square at <code>(640, 400)</code></p> </li> <li> <p>Present to the screen</p> </li> </ul> <p>All that we need to do to fix this is to just clear the screen of whatever graphics we rendered to it before we render the new graphics. In Raylib, the function for this is called <code>ClearBackground()</code>. Let's choose black for now as our clear color.</p> <pre><code>    Vector2 player_position = { 640, 360 };\n\n    while (!WindowShouldClose())\n    {\n        if (IsKeyPressed(KEY_RIGHT))\n        {\n            player_position.x += 40;\n        }\n\n        ClearBackground(BLACK);\n        BeginDrawing();\n        DrawRectangle(player_position.x, player_position.y, 40, 40, RED);\n        EndDrawing();\n    }\n</code></pre> <p>Now that we're clearing the screen \u2014 effectively erasing all the contents of it \u2014 before we draw in it, our order of rendering looks more like this.</p> <ul> <li> <p>Clear the screen</p> </li> <li> <p>Draw red square at <code>(640, 360)</code></p> </li> <li> <p>Present to the screen</p> </li> <li> <p>== NEW FRAME == </p> </li> <li> <p>Clear the screen</p> </li> <li> <p>Draw red square at <code>(640, 400)</code></p> </li> <li> <p>Present to the screen</p> </li> </ul> <p>Let's run it now and move right 3 times.</p> <p></p> <p>That's more like it. Now, let's try duplicating the logic for this across all 4 directions.</p> <pre><code>        if (IsKeyPressed(KEY_RIGHT))\n        {\n            player_position.x += 40;\n        }\n        if (IsKeyPressed(KEY_LEFT))\n        {\n            player_position.x -= 40;\n        }\n        if (IsKeyPressed(KEY_UP))\n        {\n            player_position.y -= 40;\n        }\n        if (IsKeyPressed(KEY_DOWN))\n        {\n            player_position.y += 40;\n        }\n</code></pre> <p>If we run it:</p> <p></p> <p>It finally works! We have our own player of sorts now.</p>"},{"location":"Week-1.-Making-Your-First-Game/2-The-Game-Loop/#continuous-movement","title":"Continuous Movement","text":"<p>You'll notice that currently our movement is discrete. We move 40 units, every time we press an arrow key. But we'd rather have our movement be continuous; we don't want to move just once when we press a key, we want to move continuously as we're holding a key down.</p> <p>To do this, we just need to change the function we're using <code>IsKeyPressed()</code> to the more appropriate <code>IsKeyDown()</code> instead, which will return <code>true</code> as we're holding a key down.</p> <pre><code>        if (IsKeyDown(KEY_RIGHT))\n        {\n            player_position.x += 40;\n        }\n        if (IsKeyDown(KEY_LEFT))\n        {\n            player_position.x -= 40;\n        }\n        if (IsKeyDown(KEY_UP))\n        {\n            player_position.y -= 40;\n        }\n        if (IsKeyDown(KEY_DOWN))\n        {\n            player_position.y += 40;\n        }\n</code></pre> <p>If we run it now, we can see that it kinda works, but something's off.</p> <p></p> <p>In the GIF it's a little choppy, but that's only because it's at 30 fps. Putting that aside, our player is moving way too fast. How come? Well, when we look at the code again, we can see that we're moving 40 pixels at once everytime the player moves, also, we check for input every loop (frame), so if we hold the key down, what this effectively means is we're moving 40 pixels each frame, which is obviously more than we'd want. What we'd like to have instead is to have the player move 40 pixels per second, which is totally different from 40 pixels per frame.</p> <p>We know at this point that the amount of times the game loop is executed in one second is known as the frames per second of our game (FPS), the \"frame\" in this context refers to the visual output to the screen, which is the final part of the game loop if you'd remember. However, we're going to use the term \"frame\" here to refer to the execution of the game loop in its entirety, and not just the literal visual output on the screen, which is common in game development.</p> <p>Since we're doing this movement each frame, it stands to reason that if we increase or decrease the FPS of our game the speed of the movement will follow suit. You can experiment with this and see that it's true.</p> <p>We can demonstrate this mathematically. If we add 40 to position per frame @ 60 FPS, we'll have a total displacement of 2400 per second.</p> <p></p> <p>If we try set our FPS to 120, or just demonstrate this mathematically again, we can see that the total displacement per second changes.</p> <p></p> <p>This is obviously a big problem, since we don't want something like our movement speed to be dependent on the game's FPS, as this can cause undesired and unpredictable behavior, and can give some players advantages over others depending on what FPS their machine can or cannot handle.</p> <p>In Raylib, there's a function called <code>SetTargetFPS()</code> to set the FPS for us. By default the target FPS is set to match the current monitor's refresh rate, but for the sake of consistency let's just set the target FPS to 60 before the initialization of our window.</p> <pre><code>    SetTargetFPS(60);\n    InitWindow(1280, 720, \"Pong\");\n</code></pre>"},{"location":"Week-1.-Making-Your-First-Game/2-The-Game-Loop/#delta-time","title":"Delta Time","text":"<p>Well now that we know why our player is moving much faster than we'd like, what's the solution? Since the reason for the high speed is because it's correlated to the frames of our game, what we need to do is find some way to decouple our game's logic from the FPS. In order to do this, we need to take the delta time of our game, also known as the frame time, and multiply it by all variables which we want to be per second rather than per frame.</p> <p>That's quite a lot to take in, but let's break it down. The delta time (frame time), as you may tell, is just simply the amount of time it takes to execute one frame or loop of our game. If the frames per second tells us how many frames are done per second, this is the complete opposite, it tells us how many seconds it takes to do one frame. We can get the delta time by dividing 1 by the FPS. For 60 FPS, the frame time is 0.01666 seconds, or 16.66 miliseconds, equivalent to \\(1\\over60\\).</p> Real delta time <p>In real games, the delta time is actually acquired manually, by taking the time (in seconds) at the current frame, and subtracting from the time of the previous frame.</p> <p><code>delta_time = current_time - previous_frame_time</code></p> <p>So what happens when we multiply this number by our time-dependent variables? What happens is the 40 units we wanted to move per second, are in-fact being moved per-frame but at a much slower rate than 40. How much slower? Just slow enough for it to complete 40 units by the time 1 second passes.</p> <p>We can illustrate this demonstration again for 60 FPS.</p> <p></p> <p>As you can see, the total displacement per second now is at around 40, which is our desired result. Just as importantly, if we test this on a different FPS like 120, our end result remains the same.</p> <p></p> <p>We can prove that the total displacement per seconds will always be the same regardless of the current FPS using this method mathematically. If \\(40\\) is our desired per second displacement, and we are displacing at a rate of \\(60\\) frames per second, multiplying by delta time is the same as dividing \\(40\\) by \\(60\\), and we're displacing \\(60\\) times in one second so the total displacement in seconds would look like:</p> <p>\\({40\\over60}\\times60=40\\)</p> <p>The division by 60 and multiplication by 60 cancel each other out, leaving only 40. This is obviously true for other FPS rates as well.</p> <p>Note</p> <p>This solution is not perfect. Games that require a lot of precision such as online games or fighting games need more precise solutions for decoupling FPS and game logic, and we will cover a few of them later on.</p> <p>This solution however is good enough for most cases, and it's what we'll be using for now. </p> <p>In Raylib, the function for acquiring the frame time is simply called <code>GetFrameTime()</code>, let's go ahead and store it first thing in our loop.</p> <pre><code>    while (!WindowShouldClose())\n    {\n        float delta_time = GetFrameTime();\n    \u00a0\u00a0\u00a0\u00a0...\n    \u00a0\u00a0\u00a0\u00a0...\n    }\n</code></pre> <p>Now let's take all the instances of us translating the player position by 40 units and multiply it by our delta time.</p> <pre><code>        float delta_time = GetFrameTime();\n        if (IsKeyDown(KEY_RIGHT))\n        {\n            player_position.x += 40 * delta_time;\n        }\n        if (IsKeyDown(KEY_LEFT))\n        {\n            player_position.x -= 40 * delta_time;\n        }\n        if (IsKeyDown(KEY_UP))\n        {\n            player_position.y -= 40 * delta_time;\n        }\n        if (IsKeyDown(KEY_DOWN))\n        {\n            player_position.y += 40 * delta_time;\n        }\n</code></pre> <p>And let's see what we get:</p> <p></p> <p>Well it's rather slow, but then again 40 pixels per second isn't that fast to begin with. What's important is that it works! Now that we got that out of the way we can actually begin to work on our game.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/","title":"3. Making Pong","text":""},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#structure","title":"Structure","text":"<p>The game that we're gonna be making is Pong, the first video game made.</p> <p></p> <p>There is a ball in the middle, and two paddles. The ball goes to one paddle which then hits it, and sends it back to the other paddle, if one of them fails to hit and enters their goal, that's a score for the other paddle. Really an extremely simple game.</p> <p>What we should first do is define the structure when we're making it. In this case, there are just a few elements we have to consider:</p> <ul> <li> <p>There are two paddles</p> </li> <li> <p>1 left and 1 right</p> </li> <li> <p>They can only go up and down</p> </li> <li> <p>They can hit the ball to bounce it off to the other end</p> </li> <li> <p>There's a ball</p> </li> <li> <p>It bounces off the top and bottom of the screen</p> </li> <li> <p>It bounces off the paddles</p> </li> <li> <p>If it enters a paddle's goal then it's a score for the other paddle</p> </li> <li> <p>If a goal is scored the ball and paddles are both reset to the center</p> </li> <li> <p>There is text on the top part of the screen of the paddles' scores</p> </li> </ul> <p>Let's do some housekeeping with our current code before we move any further:</p> <pre><code>const int SCREEN_WIDTH = 1280;\nconst int SCREEN_HEIGHT = 720;\n\nint main()\n{\n    SetTargetFPS(60);\n    InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, \"Pong\");\n\n    while (!WindowShouldClose())\n    {\n        float delta_time = GetFrameTime();\n\n        ClearBackground(BLACK);\n        BeginDrawing();\n        EndDrawing();\n    }\n</code></pre> <p>OK. Now let's try defining the structure of our game state. There are three main parts to it: the paddles, the ball, and the score.</p> <pre><code>struct GameState\n{\n    Rectangle right_paddle;\n    Rectangle left_paddle;\n\n    Ball ball;\n\n    int left_score;\n    int right_score;\n};\n</code></pre> <p><code>Rectangle</code> is a struct in Raylib, it has four properties.</p> <pre><code>// Rectangle, 4 components\ntypedef struct Rectangle {\n    float x;                // Rectangle top-left corner position x\n    float y;                // Rectangle top-left corner position y\n    float width;            // Rectangle width\n    float height;           // Rectangle height\n} Rectangle;\n</code></pre> <p>We'll use this struct to represent our paddle, which is simple enough. <code>Ball</code> on the other hand though, is a struct of our own that we haven't defined yet. We will define this struct later. We also have two <code>int</code> variables for our left and right scores. And really, this is all the state that we need for our game.</p> <p>There are three parts to our program: Initialization, then Updating and Drawing in a loop. Let's write these three as functions that take in\u00a0<code>GameState</code>\u00a0as a parameter.</p> <pre><code>void InitGame(GameState&amp; state);\nvoid UpdateGame(GameState&amp; state);\nvoid DrawGame(GameState state);\n</code></pre> <p>Passing by reference</p> <p>Notice that we placed an ampersand (&amp;) in the <code>GameState</code> parameters of <code>InitGame</code> and <code>UpdateGame</code>. This is because we want to pass in the state as a reference. In other words, we want the <code>InitGame</code> and <code>UpdateGame</code> functions to actually modify the state that it receives for good, and not just take it as a copy to do calculations on.</p> <p>Let's rewrite our <code>main</code> function now:</p> <pre><code>int main()\n{\n    GameState state;\n    InitGame(state);\n\n    while (!WindowShouldClose())\n    {\n        UpdateGame(state);\n        DrawGame(state);\n    }\n\n    return 0;\n}\n</code></pre> <p>When we write our code this way, the structure of our game becomes much clearer. In reality, many games/game engines follow a pattern similar to this one. Let's write some of the code for the actual functions themselves now.</p> <pre><code>void InitGame(GameState&amp; state)\n{\n    SetTargetFPS(60);\n    InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, \"Pong\");\n}\n\nvoid UpdateGame(GameState&amp; state)\n{\n}\n\nvoid DrawGame(GameState state)\n{\n    ClearBackground(BLACK);\n    BeginDrawing();\n    EndDrawing();\n}\n</code></pre> <p>Here this is just boilerplate of the same code we had earlier in <code>main</code>, you'll notice the Update function is left empty, this is because we don't yet have any logic for the game yet. We'll change that soon, but now, we have to actually define our <code>Ball</code> struct.</p> <p>The ball is similar to the paddles in the way that we don't need to store the ball's size since it's constant; the size won't ever change (unless we want it to later). One way in which they're different however, is that we actually need to store the ball's velocity. The reason is that the ball's velocity is determined solely by the angle of the paddle it hits, or when the game resets. In both these cases, we can't determine the resulting velocity in any given frame, we can only determine the velocity on the exact frame the collision or reset happens. Since we don't want to reset the velocity every frame, the only way we can tell these things is if we retain the data between frames (from the previous frame to the current one, and so on).</p> <p>When we think about the ball as mutable or variable state, there are only 2 things we have to keep track of: it's position, and it's velocity (movement). We obviously want to know it's position so that we can know the state of the board and the game, but we also want to store the velocity as a variable since we want to keep track of whatever the movement vector is if the ball hit a paddle for example. We don't really have to store the radius as a variable, since it's more of a constant.</p> <pre><code>struct Ball\n{\n    Vector2 position;\n    Vector2 velocity;\n};\n</code></pre> <p>That concludes this segment of us setting up the data, now let's actually write some code for the game's logic.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#initializing-and-drawing","title":"Initializing and Drawing","text":"<p>The first thing that we need to do is initialize the actual games state, and establish how we're gonna draw the state.</p> <p>To initialize the state, we want to do just a couple of things:</p> <ul> <li> <p>Zero out the score</p> </li> <li> <p>Place the ball in the center</p> </li> <li> <p>Set the ball's velocity to move to the right</p> </li> <li> <p>Place both paddles in the center, in their respective sides</p> </li> </ul> <p>Writing this out in code is quite simple enough. First let's just establish some constants that will be useful for us in these calculations. Let's also establish the constants for the paddle's sizes and the ball's radius. For the paddle we're just gonna go for a 10 wide and 150 tall rectangle, and the ball has a radius of 10 pixels.</p> <pre><code>const int SCREEN_TOP = 0;\nconst int SCREEN_BOTTOM = SCREEN_HEIGHT;\nconst int SCREEN_LEFT = 0;\nconst int SCREEN_RIGHT = SCREEN_WIDTH;\nconst Vector2 SCREEN_CENTER = { SCREEN_WIDTH / 2.0, SCREEN_HEIGHT / 2.0 };\n\nconst Vector2 PADDLE_SIZE = { 10, 150 };\nconst float BALL_RADIUS = 10.0f;\n</code></pre> <p>Now let's get to writing the initialization code.</p> <pre><code>const float PADDLE_OFFSET_FROM_EDGE = 40.0f;\n\nvoid InitGame(GameState&amp; state)\n{\n    SetTargetFPS(60);\n    InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, \"Pong\");\n\n    // set the ball position to the center\n    state.ball.position = SCREEN_CENTER;\n    // we want it to move right, we'll place 400 for now\n    state.ball.velocity.x = 400; // placeholder value\n\n    // set the paddles' sizes\n    state.left_paddle.width = PADDLE_SIZE.x;\n    state.left_paddle.height = PADDLE_SIZE.y;\n\n    state.right_paddle.width = PADDLE_SIZE.x;\n    state.right_paddle.height = PADDLE_SIZE.y;\n\n\n    // set the paddles' positions\n    state.left_paddle.x = SCREEN_LEFT + PADDLE_OFFSET_FROM_EDGE;\n    state.left_paddle.y = SCREEN_CENTER.y - PADDLE_SIZE.y * 0.5f;\n\n    state.right_paddle.x = SCREEN_RIGHT - PADDLE_OFFSET_FROM_EDGE - PADDLE_SIZE.x;\n    state.right_paddle.y = SCREEN_CENTER.y - PADDLE_SIZE.y * 0.5f;\n\n    state.left_score = 0;\n    state.right_score = 0;\n}\n</code></pre> <p>We're setting the paddle positions on the x axis by declaring a constant describing how big of a margin we want between the paddles and the edge of the screen, and also making sure to subtract the <code>PADDLE_SIZE.x</code> from the right paddles position taking into account that the origin of the rectangle is in the top-left. For the vertical position we just set it to the <code>SCREEN_CENTER.y</code> subtracting half the <code>PADDLE_SIZE.y</code> to make sure it's properly aligned in the center (keep in mind again that the origin of the rectangle is in the top-left).</p> <p>This initialization code seems good for now, so let's try drawing the state. This is what our <code>DrawGame()</code> function looks like right now.</p> <pre><code>void DrawGame(GameState state)\n{\n    ClearBackground(BLACK);\n    BeginDrawing();\n    EndDrawing();\n}\n</code></pre> <p>Let's add the paddles.</p> <pre><code>    DrawRectangleRec(state.left_paddle, WHITE);\n    DrawRectangleRec(state.right_paddle, WHITE);\n</code></pre> <p><code>DrawRectangleRec</code> is the same as <code>DrawRectangle</code> except it takes in a <code>Rectangle</code> struct as input, instead of 4 variables being manually set.</p> <p>Now the ball. We're going to use the <code>DrawCircle()</code> function which takes in four arguments: <code>centerX, centerY, radius, color</code>.</p> <pre><code>    DrawCircle(state.ball.position.x, state.ball.position.y, BALL_RADIUS, WHITE);\n</code></pre> <p>Finally, let's draw the text of the paddles' score. Here we'll use the <code>DrawText()</code> function which takes in five arguments: <code>text, posX, posY, fontSize, color</code>. For the <code>text</code> parameter, we'll format it the old-school way using the <code>TextFormat()</code> function provided by Raylib.</p> <pre><code>    DrawText(\n        TextFormat(\"%d\", state.left_score), // text\n        SCREEN_CENTER.x - 75, // x position\n        SCREEN_TOP, // y position; top of the screen\n        50, WHITE); // font size, color\n    DrawText(\n        TextFormat(\"%d\", state.right_score), // text\n        SCREEN_CENTER.x + 50, // x position\n        SCREEN_TOP, // y position; top of the screen\n        50, WHITE); // font size, color\n</code></pre> <p>And we're done. By the end, this is what our <code>DrawGame()</code> function should look like:</p> <pre><code>void DrawGame(GameState state)\n{\n    ClearBackground(BLACK);\n    BeginDrawing();\n\n    // Paddles\n    DrawRectangleRec(state.left_paddle, WHITE);\n    DrawRectangleRec(state.right_paddle, WHITE);\n\n    // Ball\n    DrawCircle(state.ball.position.x, state.ball.position.y, BALL_RADIUS, WHITE);\n\n    DrawText(\n        TextFormat(\"%d\", state.left_score), // text\n        SCREEN_CENTER.x - 75, // x position\n        SCREEN_TOP, // y position; top of the screen\n        50, WHITE); // font size, color\n    DrawText(\n        TextFormat(\"%d\", state.right_score), // text\n        SCREEN_CENTER.x + 50, // x position\n        SCREEN_TOP, // y position; top of the screen\n        50, WHITE); // font size, color\n\n    EndDrawing();\n}\n</code></pre> <p>With our state initialized and draw code written, once we build it, this is what it should look like.</p> <p></p> <p>Now we finally have something resembling a game on our hands. Now that we're done with this slightly tedious part we can finally get to the good part: coding the game logic.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#game-logic","title":"Game Logic","text":"<p>When we think about what we need to do for the game logic, there are a number of things we need to implement.</p> <ul> <li> <p>The paddles must move up and down according to player input</p> </li> <li> <p>The ball must also move according to its determined velocity</p> </li> <li> <p>Velocity is determined when it bounces against a paddle\u00a0\u00a0\u00a0</p> </li> <li> <p>It's vertical velocity is also flipped if it hits the top or bottom edge of the screen</p> </li> <li> <p>If a paddle scores a goal, the paddles and the ball must be reset, and the score updated</p> </li> </ul> <p>Simple enough, right? Let's take them on one at a time. First, the paddles movement.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#1-paddle-movement","title":"1. Paddle Movement","text":"<p>We covered movement in the beginning part of this section, so this should be easy enough to implement. We'll use continuous movement here, storing player input into a temporary velocity variable that we'll then use to actually displace the paddles' positions. For the left paddle, W and A will be the keys to move up and down, and for the right, UP arrow and DOWN arrow will move it. Before we do that though, we should declare a constant to describe how fast we want the paddle to move. Remember that this will be a pixels per second metric. Let's set it to the screens height so each paddle can cover the entire side of their goal within 1 second.</p> <pre><code>const float PADDLE_SPEED = (float)SCREEN_HEIGHT;\n</code></pre> <p>Now let's write the movement code. Don't forget to multiply the position displacement by delta time so it moves per second rather than per frame.</p> <pre><code>void UpdateGame(GameState&amp; state)\n{\n    float delta_time = GetFrameTime();\n\n    float right_velocity = 0.0f;\n    if (IsKeyDown(KEY_UP))\n    {\n        right_velocity -= PADDLE_SPEED;\n    }\n    if (IsKeyDown(KEY_DOWN))\n    {\n        right_velocity += PADDLE_SPEED;\n    }\n\n    float left_velocity = 0.0f;\n    if (IsKeyDown(KEY_W))\n    {\n        left_velocity -= PADDLE_SPEED;\n    }\n    if (IsKeyDown(KEY_S))\n    {\n        left_velocity += PADDLE_SPEED;\n    }\n\n    state.left_paddle.y += left_velocity * delta_time;\n    state.right_paddle.y += right_velocity * delta_time;\n}\n</code></pre> <p>Let's build it and see what we get.</p> <p></p> <p>That's that part done. Now let's try to get the ball moving.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#2-balls-movement","title":"2. Ball's movement","text":"<p>First off, let's declare a constant just like we did with the paddles to describe how fast the ball should move horizontally, and replace the placeholder value in the Initialization function. Let's go with 900 for now, which will make it cross the screen in about a second and a half.</p> <pre><code>const float BALL_SPEED = 900.0f;\n\n...\n\n\nvoid InitGame(GameState&amp; state)\n{\n    ...\n    state.ball.velocity.x = BALL_SPEED / 2.0f;\n    ...\n}\n</code></pre> <p>I chose to divide the speed by half in the Initialization, and will also do that when the ball is reset via goal since I think it's better to give players a little time to reposition before the round kicks off.</p> <p>Now let's just apply the movement in the Update function.</p> <pre><code>    state.ball.position.x += state.ball.velocity.x * delta_time;\n    state.ball.position.y += state.ball.velocity.y * delta_time;\n</code></pre> <p>Let's try running now.</p> <p></p> <p>We can see that the ball is in fact moving towards the right. Except, when it reaches the paddle it simply goes through it. The next step for us is to implement basic collision.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#21-collision-detection","title":"2.1 Collision Detection","text":"<p>Raylib already comes with functions for basic collision detection. The one we're interested in is <code>CheckCollisionCircleRec()</code>, which takes in three arguments: <code>center, radius, rec</code>. The <code>rec</code> is of type <code>Rectangle</code>.</p> <p>We already know the ball's position and radius, and the paddles are already of the <code>Rectangle</code> type, right now let's just try and create simple collision detection that flips the horizontal direction of the ball at max speed if it collides with a paddle.</p> <pre><code>    // if collided right paddle, go left\n    if (CheckCollisionCircleRec(\n            state.ball.position,\n            BALL_RADIUS,\n            state.right_paddle))\n    {\n        state.ball.velocity.x = -BALL_SPEED;\n    }\n    // if collided left paddle, go right\n    if (CheckCollisionCircleRec(\n            state.ball.position,\n            BALL_RADIUS,\n            state.left_paddle))\n    {\n        state.ball.velocity.x = BALL_SPEED;\n    }\n</code></pre> <p>Let's run it.</p> <p></p> <p>It works right. However the ball is always going to move in the same direction regardless of the angle of its collision with the paddle. In Pong, the angle of the ball's movement is determined by which part of the paddle it hit. So let's get to work on that now.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#22-reflection","title":"2.2 Reflection","text":"<p>The basic idea behind the reflection of the ball is that the closer the ball collides with the edge, the greater the angle of its velocity.</p> <p></p> <p>One way that we can solve this in code is to make a relation between the vertical (y-axis) velocity of the ball and it's distance from the center of the paddle. We'll take the difference between the ball's position and the paddle's center. Then we'll divide by half the height of the paddle (\\(Paddle\\ Height\\over2\\)), i.e. the distance from the top/bottom edge of the paddle to the center, so that the result is normalized from 0 at the ball's center, and 1 at the edge.</p> <p></p> <p>We'll call this the angle percent, because I don't really have a better name for it. The formula for it is as follows.</p> <p>\\(Angle\\ Percent={{Ball\\ Position\\ Y-Paddle\\ Center\\ Y}\\over {Paddle\\ Half\\ Width}}\\)</p> <p>Once we have this percentage, we can just multiply whatever maximum vertical velocity we want by it. In order to get the paddle's vertical center, we just take the position of its top edge (i.e., it's <code>position.y</code> variable) and add half the height to it.</p> <p>\\(Paddle\\ Center\\ Y=Paddle\\ Top\\ Edge+{Paddle\\ Height\\over2}\\)</p> <p>Let's write this out in code so we can get a better idea of it. Let's declare this maximum vertical velocity that we want as a constant.</p> <pre><code>const float BALL_MAX_VERTICAL_VELOCITY = 180.0f;\n</code></pre> <p>Now let's write out the formula.</p> <pre><code>    if (CheckCollisionCircleRec(\n            state.ball.position,\n            BALL_RADIUS,\n            state.right_paddle))\n    {\n        float paddle_center = state.right_paddle.y + PADDLE_SIZE.y * 0.5f;\n        float angle_percent = (state.ball.position.y - paddle_center) / (PADDLE_SIZE.y * 0.5f);\n        state.ball.velocity.y = BALL_MAX_VERTICAL_VELOCITY * angle_percent;\n        state.ball.velocity.x = -BALL_SPEED;\n    }\n    if (CheckCollisionCircleRec(\n            state.ball.position,\n            BALL_RADIUS,\n            state.left_paddle))\n    {\n        float paddle_center = state.left_paddle.position.y + PADDLE_SIZE.y * 0.5f;\n        float angle_percent = (state.ball.position.y - paddle_center) / (PADDLE_SIZE.y * 0.5f);\n        state.ball.velocity.y = BALL_MAX_VERTICAL_VELOCITY * angle_percent;\n        state.ball.velocity.x = BALL_SPEED;\n    }\n</code></pre> <p>To make the results more reliable, we'll check for collision with a paddle only if the ball is moving in the paddle's direction. This will guarantee that a ball doesn't collide with the same paddle 2 consecutive frames in a row, if it happens to have partially clipped inside it.</p> <pre><code>    if (state.ball.velocity.x &gt; 0) // if moving right\n    {\n        if (CheckCollisionCircleRec(\n                state.ball.position,\n                BALL_RADIUS,\n                state.right_paddle))\n        {\n            float paddle_center = state.right_paddle.y + PADDLE_SIZE.y * 0.5f;\n            float angle_percent = (state.ball.position.y - paddle_center) / (PADDLE_SIZE.y * 0.5f);\n            state.ball.velocity.y = BALL_MAX_VERTICAL_VELOCITY * angle_percent;\n            state.ball.velocity.x = -BALL_SPEED;\n        }\n    }\n    if (state.ball.velocity.x &lt; 0) // if moving left\n    {\n        if (CheckCollisionCircleRec(\n                state.ball.position,\n                BALL_RADIUS,\n                state.left_paddle))\n        {\n            float paddle_center = state.left_paddle.y + PADDLE_SIZE.y * 0.5f;\n            float angle_percent = (state.ball.position.y - paddle_center) / (PADDLE_SIZE.y * 0.5f);\n            state.ball.velocity.y = BALL_MAX_VERTICAL_VELOCITY * angle_percent;\n            state.ball.velocity.x = BALL_SPEED;\n        }\n    }\n</code></pre> <p>OK. Let's build and try it out.</p> <p></p> <p>Almost done! Only thing left to do now is to fix the ball not colliding with the top and bottom edges of the screen, which is probably the easiest thing to code here.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#23-ceiling-floor-bounce","title":"2.3 Ceiling / Floor Bounce","text":"<p>In order to get the ball to bounce from the top and bottom edges of the screen, all we need to do is check the top and bottom edge of the circle, and whether or not it's exceeded the respective top and bottom edge of the screen. If it did, we'll simply reverse the vertical velocity to the opposite direction.</p> <p>So if the bottom edge of the circle collided with the bottom edge of the screen, we would take the current vertical velocity <code>ball.velocity.y</code> and force it to be positive. Likewise with the top ceiling. To force the sign of the velocity, we could just multiply by -1, but that might be unreliable since the ball might be touching an edge of the screen for more than 1 frame if it's gone fast enough to go far off-screen. To fix that, we'll only check for a ceiling/floor hit if its moving in that direction.</p> <pre><code>    if (state.ball.velocity.y &gt; 0) // if moving down\n    {\n        // if bottom edge of ball is greater than bottom edge of screen\n        if (state.ball.position.y + BALL_RADIUS &gt; SCREEN_BOTTOM)\n        {\n            state.ball.velocity.y *= -1;\n        }\n    }\n    if (state.ball.velocity.y &lt; 0) // if moving up\n    {\n        // if top edge of ball is greater than top edge of screen\n        if (state.ball.position.y - BALL_RADIUS &lt; SCREEN_TOP)\n        {\n            state.ball.velocity.y *= -1;\n        }\n    }\n</code></pre> <p>Let's build it and run.</p> <p></p> <p>The ball may seem to clip on the edges before bouncing, this is only because the capture doesn't show the full window however. We're done with the ball now. The final step now is to implement the goal and scoring.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#3-scoring-rounds","title":"3. Scoring Rounds","text":"<p>This is also a very simple task. For this one all we have to do is see if the ball's position has touched or exceeded the right or left edge of the screen, no need to calculate for the right and left edge of the ball precisely, since this mostly will not affect gameplay in any serious way. If the ball did in-fact collide with the right or left edge, we will reset the ball's position and velocity, and increment the appropriate paddle's score.</p> <pre><code>    if (state.ball.position.x &gt;= SCREEN_RIGHT)\n    {\n        // ball entered right goal; left scored\n        state.left_score++;\n        state.ball.position = SCREEN_CENTER;\n        state.ball.velocity.y = 0.0f;\n        state.ball.velocity.x = BALL_SPEED * 0.5f;\n    }\n    if (state.ball.position.x &lt;= SCREEN_LEFT)\n    {\n        // ball entered left goal; right scored\n        state.right_score++;\n        state.ball.position = SCREEN_CENTER;\n        state.ball.velocity.y = 0.0f;\n        state.ball.velocity.x = BALL_SPEED * 0.5f;\n    }\n</code></pre> <p>Let's run it.</p> <p></p> <p>It works, and now we're done! We've finally made Pong, in it's entirety.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#tasks","title":"Tasks","text":"<p>We recommend stepping through the tutorial yourself and seeing the code get written and why it is the way it is. After you've followed this tutorial and made Pong, you are now tasked with modifying this game in three ways. In order of difficulty:</p> <ol> <li> <p>Change the colors of the game, to whichever you prefer</p> </li> <li> <p>Draw a white vertical line in the middle of the board</p> </li> <li> <p>Create two small thin obstacles, one on the left and right, such that if the ball collides with either of them its horizontal velocity <code>ball.velocity.x</code> will be flipped. (Don't worry about the collision detection not being perfect or slightly buggy, that won't be a factor for the task.)</p> </li> </ol> <p></p> <p>Hints:</p> <ul> <li> <p>Look at the Raylib cheatsheet for important functions</p> </li> <li> <p>Use <code>DrawLine()</code> for the line</p> </li> <li> <p>Create two <code>Rectangle</code> structs for the obstacles inside of <code>GameState</code></p> </li> </ul>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#conclusion","title":"Conclusion","text":"<p>This concludes our first tutorial on making your first game. Though we won't be using Raylib for the rest of the series, hopefully this tutorial was a good introduction into game programming, and how to think like a game programmer. Although we'll be transitioning to Godot from now on, don't forget that these principles you've learned will still be very important when you're actually programming. The frameworks may be different but the concepts are the same.</p> <p>See you next week!</p>"},{"location":"Week-1.-Making-Your-First-Game/Resources/","title":"Resources","text":""},{"location":"Week-1.-Making-Your-First-Game/Resources/#gcc-installation","title":"GCC Installation","text":"<ul> <li> <p>How To Install GCC/G++ On Windows - YouTube</p> </li> <li> <p>How To Install GCC On macOS - YouTube</p> </li> </ul>"},{"location":"Week-1.-Making-Your-First-Game/Resources/#game-math","title":"Game Math","text":"<ul> <li>Math for Game Developers - YouTube Series</li> </ul>"},{"location":"Week-1.-Making-Your-First-Game/Resources/#git-basics","title":"Git Basics","text":"<ul> <li> <p>Git and GitHub Tutorial for Beginners - YouTube</p> </li> <li> <p>Git Tutorial (w3schools.com)</p> </li> </ul>"},{"location":"Week-2.-Intro-to-Godot/","title":"Introduction","text":""},{"location":"Week-2.-Intro-to-Godot/#overview","title":"Overview","text":"<p>In this week, we're going to cover various game engine concepts, and get you started on using the Godot game engine to create games.</p> <p>It's worth noting that this week is extremely important as it will cover all of the fundamentals of Godot and how to use it to create games. The following weeks will mostly be about how you can apply these fundamentals to create different types of games, and practicing upon them.</p> <p>If you don't understand the basics of Godot, it will be much harder for you to progress in this bootcamp and have a clear understanding of what's going on, and your creativity will be limited too because of it.</p> <p>Thankfully, Godot is extremely simple to use and understand, so if you just focus with us a little in this week, you will be far better prepared to take on the coming weeks and unlock your full potential as a game developer using Godot.</p>"},{"location":"Week-2.-Intro-to-Godot/#_1","title":"Introduction","text":""},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/","title":"Creating a Moving Square","text":"<p>Now that we have a rough overview of Godot\u2019s core concepts, let\u2019s try them out in practice. Let\u2019s try recreating our moving red square from our introduction last week and make obstacles that it can collide with.</p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#installing-godot","title":"Installing Godot","text":"<p>Godot is a light-weight engine; the entire engine is just one executable file. Godot can be downloaded from this link.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#getting-started","title":"Getting Started","text":"<p>Once you first open Godot, you'll be taken to the \"Projects\" screen, where you can manage all your projects.</p> <p></p> <p>Let's go ahead and create our first project, you can call it anything you like. After we create our project, we'll be greeted by this screen.</p> <p></p> <p>This is the Godot interface. You can learn more about the details of the interface and how to navigate it in the Godot Resources section.</p> <p>Let\u2019s choose to create a 2D scene. This will create a \u201cNode2D\u201d node as the root node.</p> <p></p> <p>Let's rename it to \"Root\".</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#nodes","title":"Nodes","text":"<p>The \"Node2D\" node is one of the many types of nodes available in Godot. It is the node that nearly every 2D node derives from, in other words, every 2D node has the same properties and functions of a \"Node2D\" plus it's own unique properties and methods.</p> <p>When you try to create a new node, you'll be taken to the \"Create New Node\" screen, which lists all possible nodes and contains a description for each of them.</p> <p></p> <p>When it comes to the moving square we want to make, we have the option of just making a 2D image of a square that simply moves around. But we don't just want a picture of a moving box, we want an actual box object that can move and collide with other objects.</p> <p>To do this, we have to use a node of type PhysicsBody2D. For our purposes, let's choose the CharacterBody2D node.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#types-of-collisionobject2ds","title":"Types of CollisionObject2Ds","text":"<p>CollisionObject2D is an abstract node. \"Abstract\" means that the node itself is not a real node that can exist in a scene, but other that derive from it can. Basically, \"abstract\" means that the node is just a \"blueprint\" node for other nodes to derive from. Excluding RigidBody2D and it's inheritor, there are four major nodes of this type.</p> <ul> <li> <p>CharacterBody2D</p> </li> <li> <p>StaticBody2D</p> </li> <li> <p>AnimatableBody2D (inherits StaticBody2D)</p> </li> <li> <p>AreaBody2D</p> </li> </ul> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#adding-children","title":"Adding Children","text":"<p>Going back to our scene, we'll see that after we add our CharacterBody2D into the scene that nothing visually changes. Also, the node gives us a warning that it's missing a CollisionShape2D.</p> <p></p> <p>The CharacterBody2D node is only a node for specifying physics behaviour, but it doesn't specify anything about its shape or look. In order to add this functionality to our CharacterBody2D, we must simply add the two appropriate child nodes.</p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#the-collider-collisionshape2d","title":"The Collider - CollisionShape2D","text":"<p>First, let's add the CollisionShape2D. Right-click on the node and press Add Child Node.</p> <p></p> <p>Now let's choose CollisionShape2D.</p> <p></p> <p>Once we add the child, the warning on CharacterBody2D goes away but a new one on CollisionShape2D appears.</p> <p></p> <p>To fix this we must edit the properties of the node to specify an actual shape. Go to the inspector dock and let\u2019s choose the rectangle shape for our collider.</p> <p></p> <p>Once we've done that, the warnings will disappear, and we should have an actual shape of a rectangle appear in our viewport. This is the shape of the collider, in other words, this is what our CharacterBody2D node will use as a reference to check what it is and is not colliding with at any given time.</p> <p></p> <p>The blue square represents the collider, this square only appears in the editor for debug purposes, it will not show when we play the game/scene.</p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#the-square-colorrect","title":"The Square - ColorRect","text":"<p>Now that we have our CollisionShape2D child, let's add in our visual for the square. Usually, we would choose a Sprite2D node for this, which takes in an image resource and displays it in 2D space. However, Godot doesn't have ready image resources for simple shapes, so for the sake of simplicity, we'll instead use a ColorRect node, which just draws a colored 2D rectangle.</p> <p></p> Note <p>Technically, this node should be used for UI purposes, but we're using it in this case because it suits our needs well enough.</p> <p>Once we add it in, we get this.</p> <p></p> <p>The rectangle is much bigger than the collider and it's off-center. Moreover, the ColorRect is covering the collider. This is because the ColorRect node comes after the CollisionShape2D node in the hierarchy, so it gets drawn on top of it. We can change this by moving the nodes around in the hierarchy then using the red control points on the rect to get it to allign with the collider.</p> <p></p> <p>Note</p> <p>We adjust the ColorRect node using the red points to align with the collider. Godot's editor snaps the points to the nearest pixel on a pixel grid, so this is quite easy.</p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#saving-the-scene","title":"Saving the Scene","text":"<p>Now that our \"player\" box scene is ready, let's save the current scene by pressing Ctrl + S. This will open a \"Save Scene As...\" dialog box that will save the root of our scene first.</p> <p>In Godot, scenes are technically files (.tscn), same for scripts (.gd). And to play a scene, Godot must have a reference to it as a file. So to play our current scene, we must save the root file first.</p> <p></p> <p>Once we click \"Save\", it will show up in our file system.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#selecting-and-playing-the-main-scene","title":"Selecting and Playing the Main Scene","text":"<p>Let\u2019s try to play our scene now. Our root scene should be saved in our file system, so let\u2019s click the Play button now. It will be on the top-right part of the screen.</p> <p></p> <p>Once we press the play button, a dialog box will show up prompting us to select a \u201cmain scene\u201d, this is the first scene Godot will play when starting the game and can change throughout the run of the game. Currently, we only have one scene in our project, root, so we can press \"Select\" or \"Select Current\" it doesn\u2019t really make a difference.</p> <p></p> <p>If you click Select, you\u2019ll be taken to the file system to choose a scene from the available ones among the files, we only have one scene, so it doesn\u2019t matter for now.</p> <p>After choosing the scene, the game will start, and the scene will play.</p> <p></p> <p>You can notice at the top we have the name of the project, followed by (DEBUG). This indicates our game is in debug build, which means that certain functions like <code>debug_print()</code> will execute only in this mode and not in the final release build.</p> <p>You can also notice our \"player\" is in the top-left corner of the screen, just like we had originally in our Raylib section.</p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#scripting-the-player","title":"Scripting the Player","text":""},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#creating-the-script","title":"Creating the Script","text":"<p>Now that we're done with creating the node configuration for our square, let's create a script for it so it can move around.</p> <p>Click on the CharacterBody2D node and then on the button representing a script with a green plus above it to create a new script.</p> <p></p> <p>This will open a dialog box prompting you to specify the details of the script, such as its name and place in the file system, which node it inherits from, and whether to use a template.</p> <p></p> <p>For now, let's just name the script \"player.gd\" and place it in the root directory of the file system, and let's change the template to Default.</p> <p></p> <p>We now arrive at this familiar screen.</p> <p></p> <p>This is the script editor built-in to Godot for GDScript. You can learn more about the Godot Interface in the resources section.</p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#writing-the-script","title":"Writing the Script","text":"<p>By this point, you should be familiar with the code to move an object around in the screen. We know that our script extends CharacterBody2D which inherits Node2D. One of the properties of Node2D is a Vector2 variable called position.</p> <p>As you might expect, position is simply the objects position relative to its parent in the hierarchy (global_position is its true position in the coordinate space). For now, in the <code>_process</code> function, let's just move position down and to the right by adding a certain number to it and multiplying by delta to ensure it moves per second units by that number.</p> <pre><code>func _process(delta: float) -&gt; void:\n    # \"position\" -&gt; property derived from Node2D\n    position.x += 40 * delta\n    position.y += 40 * delta\n</code></pre> <p>If we run it now, we can see our square is moving steadily down and to the right.</p> <p></p> <pre><code>func _process(delta: float) -&gt; void:\n    var horizontal_movement : float = Input.get_axis(\"ui_left\", \"ui_right\")\n    var vertical_movement : float = Input.get_axis(\"ui_up\", \"ui_down\")\n    position.x += horizontal_movement * 40 * delta\n    position.y += vertical_movement * 40 * delta\n</code></pre> <p>This is the code to get our square moving according to player input. You can put it in the script and run it to verify it's working.</p> <p>Once we play our scene, we can see that the square is moving according to our input of the arrow keys properly.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#input-maps","title":"Input Maps","text":"<p>So what's really going on here?</p> <pre><code>var horizontal_movement : float = Input.get_axis(\"ui_left\", \"ui_right\")\nvar vertical_movement : float = Input.get_axis(\"ui_up\", \"ui_down\")\n</code></pre> <p>To understand what's happening here we must first understand the concept in Godot of Input Maps. Input maps are a way for us to create bindings between certain labels (names), and keys or inputs that correlate to that label.</p> <p>To see these input maps in Godot, we can go to Project Settings and check out the Input Map tab to see all of our custom and built-in input maps.</p> <p></p> <p></p> <p>We can check the Show Built-In Actions button to show all input maps provided automatically by Godot.</p> <p></p> <p>In practice, input maps are a way for us to decouple code using player input and the actual keys or buttons that input is taking.</p> <p></p> <p>In this instance, \"ui_left\" is a generic input map for navigating UI, and it's mapped across the joystick, left arrow key, and left D-Pad button.</p> <p>When it comes to the <code>get_axis</code> function we used, if we open the documentation this is what it says.</p> <pre><code>float get_axis(negative_action: StringName, positive_action: StringName) const\n</code></pre> <p>Get axis input by specifying two actions, one negative and one positive.</p> <p>This is shorthand for writing <code>Input.get_action_strength(\"position_action\") - Input.get_action_strength(\"negative_action\")</code>.</p> <p>Effectively, we're specifying a \"positive_action\" (right) and subtracting it from a \"negative_action\" (left), which gives us a value specifying how much are we moving left or right.</p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#communicating-between-nodes","title":"Communicating Between Nodes","text":"<p>You can imagine a scenario where we have multiple nodes linked to one parent scene, who want some way of communicating with each other. Or a scenario where a parent node wants to modify some property in one of its children. For something like this to happen, nodes must have access to each other in some way. In GDScript, the nodes are a variable type like any other, and they can be specified as a variable too.</p> <p>In our case, say we want to change the color of our square when the player presses enter. For this to happen, our player script must have access to the ColorRect node responsible for displaying the coloured square. Let\u2019s type it out as a property in the script.</p> <pre><code>extends CharacterBody2D\n\nvar color_rect : ColorRect\n</code></pre> <p>Now let\u2019s try to get this variable we\u2019ve created to reference our players child node, ColorRect. There\u2019s a function in Godot called get_node(), which can be called directly from a scene tree. Alternatively, the \u201c$\u201d sign in GDScript is shorthand for the same method. So, in the _ready() function we can just assign our color_rect variable to get the child node (ColorRect) of the current CharacterBody2D node the script is attached to.</p> <p></p> <p>Notice that when you press '$\" Godot tries to display the available child nodes you can choose from.</p> <pre><code>func _ready() -&gt; void:\n    color_rect = $ColorRect\n</code></pre> <p>Note</p> <p>The node selection is based off the name of the instance of the node, not its type. If we renamed our player's ColorRect node to something like Square, our code would instead say <code>color_rect = $Square</code></p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#onready","title":"@onready","text":"<p>Often in Godot, there are variables that we want to have initialized to a certain value on start-up. We do this by first defining the variable as a property of the script, then setting it to the value we want in the <code>_ready()</code> function like earlier. There is however a way to shorten this process and automatically initialize variables to a value on startup by using the <code>@onready</code> modifier when we\u2019re defining the variable and setting it to the value we want.</p> <p></p> <p>In Godot, the built-in input action that relates to the enter key is \u201cui_accept\u201d, so let\u2019s check if the player has pressed that button, and on the frame they do, let\u2019s just switch the color property of our ColorRect child to be red.</p> <pre><code>func _process(delta: float) -&gt; void:\n    if Input.is_action_just_pressed(\"ui_accept\"):\n        color_rect.color = Color.RED\n</code></pre> <p>When we press enter, the color now changes to red.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#exposing-variables-in-the-editor","title":"Exposing Variables in the Editor","text":"<p>Often in scripts there are variables that we want to tweak repeatedly until we settle on the value we like. Or there are variables that we want to be different depending on the instance of the script. If we have one enemy script for two different types of enemies for example, and we want both enemies to run at different speeds.</p> <p>In both cases, the appropriate thing to do is to \u201cexport\u201d our variables into the editor, so we can tweak them like we would any other property in the inspector dock. We do this simply by adding <code>@export</code> to our variable definition in our script.</p> <p>Currently, our script has hard-coded the speed of our player at 40 pixels a second, let\u2019s try parameterizing the speed into its own variable.</p> <p>First, let's define a speed float variable exported to the editor, and with 40 as the default value.</p> <pre><code>@export var speed : float = 40\n</code></pre> <p>Now let's replace our hard-coded 40 number with our new speed variable.</p> <pre><code>position.x += horizontal_movement * speed * delta\nposition.y += vertical_movement * speed * delta\n</code></pre> <p>If we check out our inspector dock now on our CharacterBody2D player, we'll see a new property where our player.gd script is found. This variable now directly controls the speed variable of this instance of the script. Let's change the value to 200.</p> <p></p> <p>If we run our scene now, we can see our player\u2019s speed does in fact match our new speed that we set in the editor.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Creating-a-Moving-Square/#using-node-methods-in-scripts","title":"Using Node Methods in Scripts","text":"<p>At the moment, we only have one square moving. Let's try to make some obstacles for it to collide with. In the scene tree, let's create a red StaticBody2D with a CollisionShape2D and ColorRect child nodes. Align them properly and make the ColorRect node red. We'll scale it vertically to make it taller.</p> <p></p> <p>If we play, we can see that the white moving square goes right through the obstacle.</p> <p></p> <p>The reason why this is happening is because we aren't using any particular method to move the player. We're simply adding the velocity to position. This will cause position to be displaced regardless of whether or not the movement is possible.</p> <p>In order to take into account collisions in movement, we must use particular methods of nodes to move the body. For CharacterBody2D, there are 2 methods to do this:</p> <ul> <li> <p><code>move_and_collide(velocity)</code> inherited from PhysicsBody2D</p> </li> <li> <p><code>move_and_slide()</code> unique to CharacterBody2D</p> </li> </ul> <p></p> <p>We can read more about this method in the documentation for CharacterBody2D.</p> <p></p> <p>Moves the body based on <code>velocity</code>.</p> <p>If we click on <code>velocity</code> in the documentation, it shows us that it is a <code>Vector2</code> property of the node.</p> <p></p> <p>Current velocity vector in pixels per second.</p> <p>Based on this information, we can adjust our script now to set the <code>velocity</code> property given from the CharacterBody2D node, minus the delta time multiplication (since <code>velocity</code> is already described in pixels per second). With that, our square will now move.</p> <pre><code>    velocity.x = horizontal_movement * speed\n    velocity.y = vertical_movement * speed\n\n    move_and_slide()\n</code></pre> <p>We can see now our moving body will collide with the obstacle.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Game-Engine-Concepts/","title":"Game Engines","text":"<p>Last week, we built and designed a game of Pong from scratch using Raylib. We learned the fundamentals of game programming, coordinate systems, and how to program game logic. Now, we're going to learn how to make games using game engines.</p> <p>The primary difference between making games from scratch and from engine is that, in engines, you must learn the systems the developers of the engine designed, and how you can use those systems to design games of your own.</p>"},{"location":"Week-2.-Intro-to-Godot/Game-Engine-Concepts/#what-are-game-engines","title":"What are Game Engines?","text":"<p>Game engines, put simply, are technical tools meant to assist developers in creating games without having to build everything from the ground up. As we talked about last week, many video games have common components in graphics, audio, physics, and other components.</p> <p>The purpose of a game engine is to be a generic solution for these problems. \"Generic\" meaning it tries to solve the problem to work for as many developers to make their games. Obviously, it's not possible for one game engine to solve all problems for all game developers. That's why there are multiple different engines in the industry, and each one tries to solve the common technical problems (audio, graphics, etc..) of game development in a way that allows developers to use that engine to create certain types of games.</p> <p>Within the constrained framework that game engines provide, developers have the freedom to use the systems provided to make their own games.</p>"},{"location":"Week-2.-Intro-to-Godot/Game-Engine-Concepts/#why-godot","title":"Why Godot?","text":"<p>There are various popular game engines used in the industry. Arguably the biggest three are Unity, Unreal, and Godot. For this bootcamp we chose Godot, the reason why is that Godot is one of the simplest game engines you can learn to use quickly, which makes it a perfect fit for this course. Unity and Unreal on the other hand, are more complex, conversely, they take longer to learn.</p>"},{"location":"Week-2.-Intro-to-Godot/Game-Engine-Concepts/#entities","title":"Entities","text":"<p>Despite the differences between these game engines, there are some things that most if not all game engines have in common. One of them is an entity system.</p> <p>Most engines handle their logic and data encapsulated in units called \"Entities\". Entities \u2014 also known as Game Objects or Actors \u2014 are effectively the building blocks of the game. They are the objects that populate the game world, and each entity has its own properties/data and logic/code.</p> <p>All entities have some shared and common properties. For example, each entity may have:</p> <ul> <li> <p>A name and unique ID</p> </li> <li> <p>A position in space (Can be 2D or 3D)</p> </li> <li> <p>A place in a general game hierarchy (sometimes called a tree)</p> </li> <li> <p>Some other properties depending on the game engine</p> </li> </ul> <p>We discussed last week the concept of the Update function in games. That is the code that is executed on a per-frame basis. When we were making Pong, we had one big update function to handle the logic of the entire game. In game engines, the game is still updated on a per-frame basis, however, instead of one update function to handle the entire game, there are often multiple, smaller update functions that handle the logic for each entity.</p> <p>Let's take a hypothetical example from Super Mario.</p> <p></p> <p>Here, we have multiple entities on the screen. The point to keep in mind here is that each one of these entities have their own state (data) and logic functions for being updated that are executed each frame. If we take the Mario Entity for example:</p> <pre><code>var name : String # name of the entity; \"Mario\"\nvar position : Vector2 # current position in space\nvar velocity : Vector2 # current movement vector\nvar num_lives : int # number of lives left before game is over\nvar health : float # amount of health before life is lost\nvar is_on_ground : bool # standing on ground or airborne?\n</code></pre> GDScript <p>From here on out, we'll be coding using GDScript, which is the scripting language for Godot. The examples here should apply to most engines regardless of the language.</p> <p>GDScript resembles Python in many ways. There is a page in the \"Godot Resources\" directory for learning GDScript which we recommend you read later. For now, the language is simple enough that you should be able to follow along with what's happening and what is meant by the code.</p> <p>This is the total state or data that the Mario Entity code can access and modify. If we look at another hypothetical example for the the actual code for the entity.</p> <pre><code>func Update():\n    # move left or right based on player input\n    if is_on_ground == true:\n        # handle jump if player pressed jump\n    else:\n        # currently in the air: apply gravity\n\n    if colliding_with_enemy:\n        # take damage\n</code></pre> <p>The <code>Update</code> function is the same as the one we know from before; it is run once each frame. The only difference is that this function is \"local\" to just this one entity. Every other entity similarly has its own update function and mutable state that will affect the game.</p> <p>Let's move on to another example for the Mystery Block Entity. The purpose of this entity is to spawn an item whenever Mario hits it for the first time.</p> <pre><code>var name : String # name of the entity; \"Mystery Block\"\nvar position : Vector2 # current position in space\nvar was_already_hit_before : bool # whether the block was hit before or not\nvar item : Item # what item the block gives when hit? coin, powerup, etc..\n</code></pre> <p>Here's what its logic would look like.</p> <pre><code>func Update():\n    if mario_hit_block: # mario hits the block\n        # first time mario hitting the block\n        if was_already_hit_before == false:\n            was_already_hit_before = true\n            item.Spawn()\n</code></pre>"},{"location":"Week-2.-Intro-to-Godot/Game-Engine-Concepts/#update-cycle","title":"Update Cycle","text":"<p>In game engines, there are multiple entities, therefore there are multiple <code>Update</code> functions. So, what's really happening between frames? What's happening is not much different from what you might expect or already know from last week.</p> <p>Taking the Mario example from earlier. There are at least 6 entities we highlighted. So, those are 6 <code>Update</code> functions, some of them are the same functions, but happen to be on different entities that have different data (for examaple, the Goombas are not all in the same place). In any case, each frame, the <code>Update</code> functions are all called in some order, then the frame is rendered to the screen, and it repeats.</p> <p>Frame 1</p> <ul> <li> <p>Mario <code>Update</code> is called</p> </li> <li> <p>Mystery Block <code>Update</code> is called</p> </li> <li> <p>Goomba 1 <code>Update</code> is called</p> </li> <li> <p>Goomba 2 <code>Update</code> is called</p> </li> <li> <p>Goomba 3 <code>Update</code> is called</p> </li> <li> <p>Bullet <code>Update</code> is called</p> </li> <li> <p>Each entity is rendered (drawn) to the screen</p> </li> </ul> <p>Frame 2</p> <ul> <li>Same as last frame</li> </ul> <p>No given entity's <code>Update</code> function is called more than once in the same frame, and the entities are all updated first then rendered to the screen, then the cycle repeats.</p> <p>This is how the vast majority of game engine's handle their \"entities\". Of course, each engine may have a different word for \"entity\" (GameObject for Unity, Node for Godot...) but the concept of having self-contained stateful objects that have code and exist in the game world is almost universal among the big game engines, and it's the same for all of them.</p>"},{"location":"Week-2.-Intro-to-Godot/Game-Engine-Concepts/#assets","title":"Assets","text":"<p>One final topic about common game engine elements we will discuss before moving on to the next section is assets.</p> <p>In the previous section where we made Pong, we depended entirely on just rectangles and circles for the visuals. Ideally though, our game would have more detailed and advanced digital content such as models, images, textures, sounds, etc...</p> <p>These pieces of digital content that go into our game are called assets. Game engines come with their own way of importing assets and using them in-game.</p> <p>Assets can be tethered or connected to our entities to create believable, immersive, and coherent game worlds. They can be set through the editor of the engine, or set and changed through code to respond to events.</p> <p>Here's an example of a Mario sprite asset being used inside the Super Mario game.</p> <p></p> <p>As you can see, there is a general \"sheet\" of sprites containing many images of Mario, but in the game, we can see Mario as an entity clearly moving around and interacting with the world. In here, it's as if we've \"clipped\" the sprite from the sheet, and glued it onto the Mario entity in the game to give it life.</p> <p>In reality, this is what happens most of the time in game engines. If the sprite didn't exist, we would not be able to see Mario at all, or we would see him just as a lifeless rectangle. The asset we import from the sheet to the game gives our entity life.</p> <p>And with that, we conclude this section on game engines. In the next section, we will talk more about Godot and how it works.</p>"},{"location":"Week-2.-Intro-to-Godot/Making-a-Simple-Platformer/","title":"Making a Simple Platformer","text":""},{"location":"Week-2.-Intro-to-Godot/Making-a-Simple-Platformer/#refactoring","title":"Refactoring","text":"<p>Let's try and make a simple platformer, where the player can move and jump, and their goal is to reach a certain point in the level.</p> <p>First, let's try and reorganize our code and input maps to be better organized. Let's use the input map feature of Godot to define certain input actions and their associated keys. We want the player to be able to move left and right, and jump.</p> <p>Let's define each of these three actions.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Making-a-Simple-Platformer/#player-script","title":"Player Script","text":"<p>Now let's rewrite our player's code.</p> <pre><code>@export var speed : float = 400\n\nfunc _physics_process(delta : float) -&gt; void:\n    var input_direction : float = Input.get_axis(\"player_left\", \"player_right\")\n    velocity.x = input_direction * speed\n\n    move_and_slide()\n</code></pre> <p>Physics Process</p> <p>In Godot, there are two \"update\" functions. A regular _process() function, and a specialized _physics_process() function.</p> <p>The regular _process() updates every frame it possibly can, it's better suited for game logic related code.</p> <p>The _physics_process() on the other hand, updates on a fixed timestep, which means it's scheduled to execute on a certain timescale (every 0.05 seconds, for example).</p> <p>The schedule will never change, not as the game is running nor across different devices. The _process() however is variable (changes with FPS).</p> <p>This makes _physics_process() better for handling physics computations, since it will make the physics outcomes our code more deterministic and less random.</p> <p>You can read more about the different process functions on Godot's official documentation on the subject.</p> <p>This will make our player move only left and right based on input. Let's scale the player up in our game (press the S key in the editor to switch to scale mode) and play.</p> <p></p> <p>Let's place the obstacle underneath the player now towards the bottom of the screen, and try to apply gravity in our code.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Making-a-Simple-Platformer/#gravity","title":"Gravity","text":"<p>We want to apply gravity so long as the player is not on the ground. If we open the docs for the CharacterBody2D node, we can find a suite of methods for detecting which part of the node is colliding with which direction.</p> <p></p> <p>The one we're interested in is <code>is_on_floor()</code>, particularly, we're interested in when this methods return value is false.</p> <p>We need to do a check in the script to see if this method return value is false.</p> <pre><code>    var input_direction : float = Input.get_axis(\"player_left\", \"player_right\")\n    velocity.x = input_direction * speed\n\n    if not is_on_floor():\n        # apply gravity\n</code></pre> <p>When this <code>is_on_floor()</code> is false, we know we're in the air. When we're in the air, we want to apply gravity. One way to do this is to create a simple <code>gravity</code> property in the player script and set <code>velocity.y</code> to this property when we're in the air.</p> <pre><code>@export var speed : float = 400\n@export var gravity : float = 500\n\nfunc _physics_process(delta: float) -&gt; void:    \n    var input_direction : float = Input.get_axis(\"player_left\", \"player_right\")\n    velocity.x = input_direction * speed\n\n    if not is_on_floor():\n        velocity.y = gravity\n</code></pre> <p>But there's a problem with this code. In the real world (and in games too), gravity is an accelerant to velocity. In other words, velocity is not equal to gravity, it is accelerated by gravity. The relation we've specified in the code is an equal to relationship <code>velocity.y = gravity</code>, if we want to be more accurate, it would be an acceleration relation <code>velocity.y += gravity</code>.</p> <p>But there's another problem with <code>velocity.y += gravity</code>, if we're adding gravity every frame, that means the rate of acceleration will be variable depending on the frames per second, to decouple FPS from the acceleration we need to multiply by delta <code>velocity.y += gravity * delta</code>.</p> <pre><code>    if not is_on_floor():\n        velocity.y += gravity * delta\n</code></pre> <p>This is a more accurate application of gravity in our script code.</p> <p>If we run it now, we can see our player will move down and land on the obstacle, and continue accelerating downwards when we move off of it.</p>"},{"location":"Week-2.-Intro-to-Godot/Making-a-Simple-Platformer/#jumping","title":"Jumping","text":"<p>Now we want our player to be able to jump. The way we do this is by first checking if we are on the ground, and checking if we have pressed the jump button, since those are two condition we need to make sure are true when we jump.</p> <p>This is pretty straightforward, we already know the function to check if we're on the floor, and the function to check if we've pressed an action is <code>Input.is_action_just_pressed(\"action\")</code>.</p> <p>When we jump, we want to set <code>velocity.y</code> to some force that goes upwards, and then we'll just let gravity do the rest. What will happen is the player will move upwards at a decreasing rate, until it stops at the peak and then accelerates downwards.</p> <p>We'll create a variable called <code>jump_force</code> to describe what this initial <code>velocity.y</code> is upon jumping.</p> <pre><code>@export var jump_force : float = -400\n</code></pre> <p>Then when the conditions for jumping are fulfilled we'll set <code>velocity.y</code> equal to this jump force.</p> <pre><code>    if is_on_floor():\n        if Input.is_action_just_pressed(\"player_jump\"):\n            velocity.y = jump_force\n</code></pre> <p>Once we run it we can see we're jumping properly now.</p> <p></p> <p>Now we've done most of everything related to the player script, let's try to complete the other parts of our platformer.</p>"},{"location":"Week-2.-Intro-to-Godot/Making-a-Simple-Platformer/#obstacle-scene","title":"Obstacle Scene","text":"<p>At the moment, in our scene tree, the obstacle is just another \"branch\" for the root node. It's not considered its own scene.</p> <p></p> <p>What we want to do is to make this branch its own scene. The reason we want to do this is so that we can get control over every instance of the scene.</p> <p>The way we do this is by right-clicking on the node we want to make its own scene, and clicking on \"Save Branch as Scene...\" This will prompt us to name our scene file and place it in our file system.</p> <p></p> <p>I've made 2 folders, a Scripts and Scenes folder to better organize our assets. I'll place our new obstacle scene in the Scenes folder.</p> <p></p> <p>Once we save it we can see in our tree, in place of our old branch we just have an Obstacle node that we can't expand to see its children. However there is a strange film-director icon next to it. When we press it, it will take us to a new tab with just the obstacle scene by itself.</p> <p></p> <p></p> <p>In this independent scene, our obstacle node is not centered in the origin. This is not ideal since it will make placement of our scene in another scene odd since it might not always land where we expect it to as soon as we place it in the scene.</p> <p>Let's just center the scene to the origin.</p> <p></p> <p>Once we return to our root scene, the obstacle will be in the origin. That's fine, just change its position back. Let's copy the obstacle now and create a sort of level with obstacles. Make sure the pasted obstacles are children of root!</p> <p></p> <p>Let's play and test the level.</p> <p></p> <p>It works fine, but what if we want to change the color of the obstacles? Like orange for example.</p> <p>Before saving our obstacle as a scene, we would've have had to manually change the color of each obstacle, one by one. But now that our obstacle is its own scene, all that we have to do is go to that scene and change it's color, and all of the instances of that scene in other places will change as well.</p> <p></p> <p>If we save and go back to our root scene, all of the obstacles will have changed colors now.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Making-a-Simple-Platformer/#creating-a-door-to-another-scene","title":"Creating a Door to Another Scene","text":"<p>Having this basic platformer is good, but what if we want an end to the level? Say, a door, that once touched by the player will change the current scene to a separate scene that has the text \"Congratulations, we've just made our first game in Godot!\".</p> <p>Let's create such a scene, in the top part of the screen, there's a \"+\" icon next to the tabs. Clicking on it will create a new scene.</p> <p></p> <p></p> <p>Let's create a \"Label\" node as the root of this scene.</p> <p></p> <p>Let's adjust its properties so that it's centerd in the middle of the screen and has the text we want.</p> <p></p> <p>Let's save it as \"win_screen.tscn\" in our Scenes folder in the file system.</p> <p></p> <p>Now let's create the \"Door\" scene.</p> <p>For this, we'll just make an Area2D node with ColorRect and CollisionShape2D children.</p> <p></p> <p>Let's save it as \"door.tscn\".</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Making-a-Simple-Platformer/#scripting","title":"Scripting","text":"<p>We'll stay in our \"Door\" scene tab for now, let's create the script for detecting if the player has touched the door.</p> <p>For this we'll use signals. Which are kind of like events or announcements that an event has occurred stemming from one node. Other nodes can respond to this event in whatever they like.</p> <p>When you open the documentation for a node, you can see all of the signals of that node. For Area2D, the event we're interested in is <code>body_entered</code>.</p> <p></p> <p>We'll create a script for the door node called \"door.gd\" (place it in the Scripts folder). Let's hook up this <code>body_entered</code> signal to our new door script.</p> <p>The way we do this is by clicking on the \"Node\" tab next to our inspector window.</p> <p></p> <p>When you select a node in the scene tree, it will show you all of the signals of that node.</p> <p></p> <p>From here you can link a signal to a script. Let's click on body_entered and connect it to our Door node.</p> <p></p> <p>This will create a new receiver method in our Door script. The green arrow means the method is a receiver method, which means it will execute in response to a signal being emitted. In this case, this method will execute once our Area2D door detects a body entering the area. In other words, when our player touches it.</p> <p></p> <p>Now let's make it change scenes once we've touched it. The function to do this is <code>get_tree().change_scene_to_file(\"scene)</code>. Once you type it out, it will fill an autocorrect with all scenes in the file system.</p> <p></p> <p>Let's choose our new \"win_screen.tscn\" scene.</p> <pre><code>func _on_body_entered(body: Node2D) -&gt; void:\n    get_tree().change_scene_to_file(\"res://Scenes/win_screen.tscn\")\n</code></pre> <p>Now let's finally place this new Door scene in our root. Just go back to our root scene and drag the door.tscn from the file system to the tree. Again make sure it's a child of root.</p> <p></p> <p>Now once we play, it should work.</p> <p></p> <p>And that's it! That's our first game made in Godot.</p>"},{"location":"Week-2.-Intro-to-Godot/Nodes-and-Scenes/","title":"Nodes and Scenes in Godot","text":""},{"location":"Week-2.-Intro-to-Godot/Nodes-and-Scenes/#nodes","title":"Nodes","text":"<p>Nodes are the building blocks of your game in Godot. They are kind of like entities. There are different types of nodes, and each type has its own predefined behaviour and properties that can be extended using scripts.</p> <p></p> <p>The developers of Godot describe nodes as like ingredients in a recipe.</p> <p>All nodes have:</p> <ul> <li> <p>A Name</p> </li> <li> <p>Editable Properties</p> </li> <li> <p>Callbacks (Methods) to Update Every Frame</p> </li> <li> <p>Extensible Properties and Functions</p> </li> <li> <p>Can be Added to Other Nodes as Children</p> </li> </ul>"},{"location":"Week-2.-Intro-to-Godot/Nodes-and-Scenes/#scenes","title":"Scenes","text":"<p>The last of those properties \u2014 the ability to add nodes to other nodes to create children \u2014 is arguably the most important.</p> <p>Nodes can be attached to each other as children to form trees of nodes called scenes. These scenes can all be combined with each other to form one, coherent game.</p> <p>Official Godot Example</p> <p></p> <p>Extended Example Tree</p> <p></p> <p>You can watch this video at this timestamp by Brackeys to learn more about how this works.</p>"},{"location":"Week-2.-Intro-to-Godot/Nodes-and-Scenes/#node-inheritance","title":"Node Inheritance","text":"<p>Nodes \u201cinherit\u201d other nodes. Meaning that if a node inherits another node, all of that parent\u2019s properties and methods will pass on to the inherited node.</p> <p></p> <p>Notice that with each descending node type, all of the properties and methods of the node it inherits from exists within it, in addition to some unique properties and methods.</p>"},{"location":"Week-2.-Intro-to-Godot/Nodes-and-Scenes/#node-nesting","title":"Node Nesting","text":"<p>Nodes being attached to other nodes as children will make their position relative to its parent node. \"Relative\" in this case means that its origin point is the position of its parent node.</p> <p>Here's an example.</p> <p></p> <p>Node B is a child of Node A. It's local position is (0, 0). This means it's real (global) position is the same as Node A's global position.</p> <p>Another example:</p> <p></p> <p>Here, Node B is still a child of Node A. But it's local position is (-2, 0). This means that wherever Node A is, Node B will always be (-2, 0) or two units left of Node A's position.</p> <p>An example of where this might be useful for game development is if you have a player character carrying a weapon that has its own hitbox, you can make the weapons position relative to the player, and the weapon can move around the player in any direction you specify.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Nodes-and-Scenes/#scripting","title":"Scripting","text":"<p>In addition to their predefined behaviour, nodes can have behaviour defined by scripts the developer creates to take advantage of the capabilities offered by a node. Each node can have only one script attached to it. When you create a node, it will automatically be filled out with three things.</p> <p></p> <p>Godot has built-in documentation that explains each node. You can reach this documentation by holding down ctrl and pressing on a node or other keyword you want to learn more about.</p> <p>The documentation for Godot and its nodes is very good. When you're scripting for a node you're not familiar with or are encountering bugs from a specific node, you'll often be going to the node's documentation to see exactly what it does.</p>"},{"location":"Week-2.-Intro-to-Godot/Tasks/","title":"Tasks","text":"<p>For this week, you have 3 tasks. You must build upon the work done in the workshop to make the game more sophisticated.</p>"},{"location":"Week-2.-Intro-to-Godot/Tasks/#task-1-use-collision-layers-and-masks-to-make-door-only-collide-with-the-player","title":"Task 1: Use Collision Layers and Masks to Make \"Door\" Only Collide with the Player","text":"<p>In our current scene, when the door touches anything, it will trigger the signal and change the scene.</p> <p></p> <p>Your task is to use the Collision layers and masks feature in Godot to filter out the non-player colliders from the player colliders.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Tasks/#hints","title":"Hints","text":"<p>You can set-up the collision layers like this.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Tasks/#task-2-create-a-killzone-scene-that-resets-the-current-scene-when-the-player-touches-it","title":"Task 2: Create a \"Killzone\" Scene that Resets the Current Scene when the Player Touches it","text":"<p>Currently, if our player falls off the obstacle, he keeps falling down infinitely and the game doesn't reset it.</p> <p></p> <p>Your task is to create a new scene and script of type Area2D called \"Killzone\".</p> <p>You should place the node underneath the level and scale it horizontally to cover as much area so that when the player falls off, he will certainly touch the killzone.</p> <p></p> <p>Once the player touches this \"killzone\" the game will reset the current scene.</p>"},{"location":"Week-2.-Intro-to-Godot/Tasks/#hints_1","title":"Hints","text":"<ul> <li> <p>Use the <code>body_entered</code> signal.</p> </li> <li> <p>The method to reload the scene: <code>get_tree().reload_current_scene()</code></p> </li> </ul>"},{"location":"Week-2.-Intro-to-Godot/Tasks/#task-3-make-a-level-2-scene-with-obstacles-and-a-player-in-the-door-script-make-the-scene-that-is-switched-to-when-the-player-touches-it-variable","title":"Task 3: Make a Level 2 Scene with Obstacles and a Player, in the Door Script, Make the Scene that is Switched to When the Player Touches it Variable","text":"<p>Currently, when our player touches the door, we are transported to the win_screen scene. What if we wanted to make it go to a level 2 instead? And what if we want we want Level 2 to go to the win screen?</p> <p></p> <p>Your task is to make a level 2 scene with a player, obstacles, killzone and a door that goes to the win screen.</p> <p>In the first scene, make the door instead go to this new level 2 scene.</p>"},{"location":"Week-2.-Intro-to-Godot/Tasks/#hints_2","title":"Hints","text":"<ul> <li> <p>The method to use instead of changing from file in <code>door.gd</code>: <code>get_tree().change_scene_to_packed()</code></p> </li> <li> <p>The way to make an exported PackedScene variable in <code>door.gd</code>: <code>@export var next_scene : PackedScene</code></p> </li> </ul>"},{"location":"Week-2.-Intro-to-Godot/Tasks/#how-to-submit-the-task","title":"How to Submit the Task","text":"<p>The setup or template of the task is a Github Repository. You must fork the repository, clone it to your device, work on it, push it, and then make a pull request.</p>"},{"location":"Week-2.-Intro-to-Godot/Tasks/#1-forking-the-repository","title":"1. Forking the Repository","text":"<p>Now you should have a version of this repository under your account.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Tasks/#2-cloning-the-repository-and-adding-it-as-a-project","title":"2. Cloning the Repository and Adding it as a Project","text":"<p>Go to the folder where you want to work on the task.</p> <p>Copy the link for your git repo.</p> <p></p> <p>Open the terminal for the folder where you want to work on the task.</p> <p></p> <p>type <code>git clone</code> and paste your repository link.</p> <p></p> <p>Press enter.</p> <p></p> <p>Now open Godot. In the project manager, click on \"Import\".</p> <p></p> <p></p> <p>Choose the folder you cloned using <code>git clone</code>.</p> <p></p> <p>Click \"select this folder\". Then \"Import &amp; Edit\".</p> <p></p> <p>Now click on \"root.tscn\" in the file system and begin working on the tasks. If it says there's a dependency error regarding \"level_2.tscn\", ignore it.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Tasks/#3-after-youre-done-working-on-the-tasks","title":"3. After You're Done Working on the Tasks","text":"<p>Go back to the terminal where the folder you cloned was. Enter into the folder in the terminal.</p> <p></p> <p>Enter <code>git add -A</code>.</p> <p></p> <p>Then <code>git commit -m \"message\"</code>. You can make the message whatever you want.</p> <p></p> <p>Finally <code>git push</code>.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/Tasks/#4-make-the-pull-request","title":"4. Make the Pull Request","text":"<p>Back on your GitHub page for the repo. Click on \"Pull Requests\", and create a pull request. Be sure to name the PR with:</p> <p>Your Full Name - Week 2 Task</p> <p></p> <p>You'll know the task is submitted when you go to the Pull Requests tab of the original repo and you see your name in it.</p> <p></p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/","title":"GDScript","text":""},{"location":"Week-2.-Intro-to-Godot/GDScript/#what-is-gdscript","title":"What is GDScript?","text":"<p>Behind every game, there is a programming language that powers it.\u00a0GDScript\u00a0is the one that\u2019s custom-made for Godot. It is simple, clutter-free, and tightly integrated with the engine, with its creators deeming it easy for beginners to learn. It was created with the intent of helping users focus on the engine rather than on spending time learning how to integrate code written in other languages. It also enables developers to easily get rid of bugs in the engine code and effortlessly introduce new features. That being said, Godot also has support for other languages such as C++ and C#, among others, which are primarily supported by the Godot community.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/#scripting","title":"Scripting","text":"<p>A script is a piece of code that adds logic to a node, such as moving an image or deciding when to play that sound. To start scripting and trying out the examples given, you will need to create a new project, add a node to the scene, and attach a script to that node.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Array/","title":"Array","text":"<p>An\u00a0array is a data type that stores a set of variables at different index positions. You can think of it as a set of address locations, with each location holding a different value or variable. Each stored item is called an\u00a0element\u00a0and can be accessed using its index, starting from index 0.</p> <p>Here\u2019s an example of an array called <code>Games</code>, which stores the names of four different video games:</p> <pre><code>var Games = [\"Mario\", \"Donkey Kong\", \"Pac-man\", \"Breakout\"]\n\nfunc _ready():\n     print(Games[0])\n     print(Games[1])\n     print(Games[2])\n     print(Games[3])\n</code></pre> <p>Output:</p> <pre><code>Mario\nDonkey Kong\nPac-man\nBreakout\n</code></pre> <p>As we see at the output, Mario is stored at index 0, Donkey Kong at index 1, Pac-man at index 2, and Breakout at index 3. Taking this Games array as an example, let\u2019s look at some typical array functions.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Array/#1-count-the-number-of-elements-using-size","title":"1 - Count the number of elements, using <code>size()</code>","text":"<pre><code>var num_elements = Games.size()\nprint(num_elements)\n</code></pre> <p>Output</p> <p><code>4</code></p> <p>Since <code>Games</code> has four different items, the output will be 4.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Array/#2-check-whether-it-contains-a-specific-element-using-find","title":"2 - Check whether it contains a specific element, using <code>find()</code>","text":"<pre><code>print(Games.find(\"Pac-man\"))\n</code></pre> <p>Output</p> <p><code>2</code></p> <pre><code>print(Games.find(\"Ms. Pac-man))\n# Checks whether Ms. Pac-man appears in Games\n</code></pre> <p>Output</p> <p><code>-1</code></p> <p>Since Pac-man is present at the index number 2 in <code>Games</code>, the output is 2 for this case. On the other hand, since \u201cMs. Pac-man\u201d is not part of <code>Games</code>, we get a value of -1 at the output.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Array/#3-check-the-number-of-times-an-element-occurs-using-count","title":"3 - Check the number of times an element occurs, using <code>count()</code>","text":"<pre><code>var count_element = Games.count(\"Breakout\")\nprint(count_element)\n</code></pre> <p>Output</p> <p><code>1</code></p> <p>As \"Breakout\" only appears once in <code>Games</code>, the output is 1.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Array/#4-add-an-item-to-the-end-of-the-array-using-append","title":"4 - Add an item to the end of the array, using <code>append()</code>","text":"<pre><code>Games.append(\"Tron\")\nprint(Games)\n</code></pre> <p>Output</p> <p><code>[Mario, Donkey Kong, Pac-man, Breakout, Tron]</code></p> <p>In this example, we're simply adding \"Tron\" to <code>Games</code>.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Array/#5-shuffle-the-order-of-the-items-using-shuffle","title":"5 - Shuffle the order of the items, using <code>shuffle()</code>","text":"<pre><code>randomize()\nGames.shuffle()\nprint(Games)\n</code></pre> <p>Output</p> <p><code>[Donkey Kong, Tron, Breakout, Mario, Pac-man]</code></p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Dictionaries/","title":"Dictionaries","text":"<p>In GDScript, a dictionary can be thought of as a\u00a0container\u00a0that stores unique keys, as well as different values associated with each of them. It\u2019s similar to an array, but the stored values do not have a corresponding index. Instead, you can look up a particular value by searching for its key.</p> <p>Let\u2019s create a dictionary that holds information about the attributes of a game character by storing key-value pairs in a variable called\u00a0<code>Player</code>. Note that the dictionary definition can be declared either inside a function (e.g.\u00a0<code>func _ready</code>) or outside any of the functions in the script. The print statements should be included within a function.</p> <pre><code>var Player = {\"Type\": \"Wizard\", \"Age\" : \"500\", \"Strength\" : \"Magic\", \"Weakness\" : \"Silver\"}\nprint(Player.Type)\nprint(Player.Age)\nprint(Player.Strength)\nprint(Player.Weakness)\n</code></pre> <p>Output</p> <pre><code>Wizard\n500\nMagic\nSilver\n</code></pre> <p>In this\u00a0example,</p> <ul> <li> <p><code>Type</code>\u00a0is the key,\u00a0<code>Wizard</code>\u00a0is the value.</p> </li> <li> <p><code>Age</code>\u00a0is the key,\u00a0<code>500</code>\u00a0is the value.</p> </li> <li> <p><code>Strength</code>\u00a0is the key,\u00a0<code>Magic</code>\u00a0is the value.</p> </li> <li> <p><code>Weakness</code>\u00a0is the key,\u00a0<code>Silver</code>\u00a0is the value.</p> </li> </ul> <p>As shown in the example, we can print every element of the dictionary by accessing it using\u00a0<code>dictionary_name.key</code>\u00a0and replacing\u00a0<code>dictionary_name</code>\u00a0with the name of the dictionary and\u00a0key\u00a0with the name of the key linked to the particular element we want to access.</p> <p>For instance, we can use\u00a0<code>Player.Strength</code>\u00a0to get the value\u00a0<code>Magic</code>. We get the same result if we use\u00a0<code>Player [\"Strength\"]</code>.</p> <p>Let\u2019s look at some of the things we can do with dictionaries. Note that the code shown in the following examples (1 to 5) should be included within a function (e.g.\u00a0<code>func _ready</code>), and properly indented.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Dictionaries/#1-check-if-it-is-completely-empty","title":"1. Check if it is completely empty","text":"<pre><code>if Player.empty():\n      print(\"The dictionary is empty!\")\nelse:\n      print(\"It's not empty\")\n</code></pre> <p>Output</p> <p><code>It's not empty</code></p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Dictionaries/#2-check-the-number-of-elements","title":"2. Check the number of elements","text":"<pre><code>Check the number of elements.\nvar num_elements = Player.size()\nprint(num_elements) # displays the number of values stored\n</code></pre> <p>Output</p> <p><code>4</code></p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Dictionaries/#3-check-if-it-contains-a-particular-key","title":"3. Check if it contains a particular key","text":"<pre><code>if Player.has(\"Hobby\"):\n      print(\"The key called Hobby exists\")\nelse:\n      print(\"No such key exits in this dictionary\")\n</code></pre> <p>Output</p> <p><code>No such key exists in this dictionary</code></p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Dictionaries/#4-print-all-the-keys","title":"4. Print all the keys","text":"<pre><code>var all_keys = Player.keys() #keys() returns all the keys\nprint(all_keys)\n</code></pre> <p>Output</p> <p><code>[Type, Age, Strength, Weakness]</code></p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Dictionaries/#5-print-all-elements","title":"5. Print all elements","text":"<pre><code>var elements = Player.values()\nprint(elements)\n</code></pre> <p>Output</p> <p><code>[Wizard, 500, Magic, Silver]</code></p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Dictionaries/#6-add-items","title":"6. Add items","text":"<pre><code>func new_item (key,element_value):\n       Player[key] = element_value\n       print(\"The added key is: \",key)\n       print(\"The added value is: \",Player[key])\n       print(\"Updated dictionary: \",Player)\nfunc _ready():\n       new_item(\"Fav_Food\", \"pizza\")\n</code></pre> <p>Output</p> <pre><code>The added value is: pizza\nUpdated dictionary: {Age:500, Fav_Food:pizza, Strength:Magic, Type:Wizard, Weakness:Silver}\n</code></pre> <p><code>Fav_Food</code>\u00a0is the key, and\u00a0pizza\u00a0is the value that is passed to\u00a0<code>new_item()</code>\u00a0from\u00a0<code>_ready()</code>.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Functions/","title":"Functions","text":"<p>A\u00a0function\u00a0is an organized block of code that groups together related actions or tasks. It helps make the code more\u00a0readable\u00a0by avoiding writing the same code in multiple places. For example, you might have a function to calculate and display the total points a player earns in a game. Since these points will keep changing throughout the game, we can use this function every time we want to update the score.</p> <p>The function\u00a0<code>_ready()</code>\u00a0is an important GDScript function that is called every time a node is created in the Scene tree. Another important function is called\u00a0<code>_process (_delta)</code>\u00a0, which is executed for every frame in the game. Here,\u00a0<code>delta</code>\u00a0represents the total time between each frame. These two built-in functions can be changed according to our programming needs. We can also create our own functions for different tasks, such as creating a coin-collection system, spawning enemies, and calculating player health.</p> <p>Every function starts with the keyword\u00a0<code>func</code>\u00a0and can\u00a0return\u00a0a value that we can use somewhere else in our code. You can also choose to pass values, called\u00a0arguments, to a function if you need to use them there.</p> <p>In the first example given in the \u201cSnippets of Syntax\u201d, we declare a function for printing a user\u2019s name. This function, called\u00a0<code>print_my_name</code>, has an input parameter called\u00a0<code>my_name</code>. We pass the string \"Lisa\"\u00a0as an input to this function when we call it in the\u00a0<code>_ready()</code>\u00a0function\u00a0. In this way, the variable\u00a0<code>my_name</code>\u00a0stores the string\u00a0\"Lisa\", and the sentence\u00a0\"Hi, my name is Lisa\"\u00a0is printed at the output.</p> <p>In the second example, we have a function called\u00a0<code>add</code>\u00a0that takes two numbers,\u00a0<code>num1</code>\u00a0and\u00a0<code>num2</code>, as input, prints each of them, and returns their sum to the\u00a0<code>_ready()</code>\u00a0function. In\u00a0<code>_ready()</code>, we declare a variable called\u00a0<code>my_sum</code>\u00a0and pass the values 5 and 6 to\u00a0<code>num1</code>\u00a0and\u00a0<code>num2</code>, respectively. When we print the variable\u00a0<code>my_sum</code>, the sum of these two numbers, i.e., 11, is displayed at the output.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Functions/#snippets-of-syntax","title":"SNIPPETS OF SYNTAX","text":""},{"location":"Week-2.-Intro-to-Godot/GDScript/Functions/#1-passing-and-printing-a-name","title":"1. Passing and Printing a Name","text":"<pre><code>func print_my_name(my_name):\n     print(\"Hi, my name is \",my_name)\n\nfunc _ready():\n     print_my_name(\"Lisa\")\n</code></pre> <p>Output</p> <p><code>Hi, my name is Lisa</code></p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Functions/#2-passing-numbers-to-a-function-and-adding-them-together","title":"2.\u2002Passing Numbers to a Function and Adding Them Together","text":"<pre><code>func add(num1, num2):\n     print(\"num1 = \",num1)\n     print(\"num2 = \",num2)\n     return num1 + num2\n\nfunc_ready():\n     var my_sum = add(5, 6)\n     print(my_sum)\n</code></pre> <p>Output</p> <pre><code>num1 = 5\nnum2 = 6\n11\n</code></pre> <p>You can declare variables either locally (inside a function) or globally (outside of any function). A local variable is visible only in the function in which it is declared, while a global variable is visible to all the functions in the code. In the example shown earlier, the variable\u00a0<code>my_sum</code>\u00a0is local to the\u00a0<code>_ready()</code>\u00a0function.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/If-else/","title":"If-else Statements","text":"<p>Whenever we want to set certain conditions before executing a block of code, we can write\u00a0if-else\u00a0statements\u00a0. We use these statements when we want to tell the computer, \u201cIf something happens, then do this; else do something else.\u201d The keyword\u00a0if\u00a0checks whether a certain condition is true and executes a certain portion of code if it is. If it\u2019s not, then we can check whether other conditions are true using\u00a0elif\u00a0statements and specify the corresponding blocks of code that need to be executed for each particular case. If none of the conditions is true, the code specified under the\u00a0else\u00a0condition is executed.</p> <p>Whenever we want to set certain conditions before executing a block of code, we can write\u00a0if-else\u00a0statements\u00a0. We use these statements when we want to tell the computer, \u201cIf something happens, then do this; else do something else.\u201d The keyword\u00a0if\u00a0checks whether a certain condition is true and executes a certain portion of code if it is. If it\u2019s not, then we can check whether other conditions are true using\u00a0elif\u00a0statements and specify the corresponding blocks of code that need to be executed for each particular case. If none of the conditions is true, the code specified under the\u00a0else\u00a0condition is executed.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/If-else/#snippets-of-syntax","title":"SNIPPETS OF SYNTAX","text":"<p>Let\u2019s take a gaming scenario to see this logic in action:</p> <p>If a player\u2019s health is below or equal to 10%, the player needs to collect one healing powerup to increase health to 50% and two healing powerups to increase health to 100% to continue playing the game. But if the player doesn\u2019t collect any powerups and the player\u2019s health falls to 0, the game is over.</p> <p>This can be represented by the following code:</p> <pre><code>extends Node2D\nvar health = 100 # Initial value that will change in the game\nvar powerup\nfunc _ready():\n      if health &lt;= 10:  # Check if Player's health is below or equal to 10 %\n            if powerup == 1:\n                  print(\"You got one power-up! Health= 50%\")\n            elif powerup == 2:\n                  print(\"You got two power-ups! Health= 100%\")\n            else:\n                  print(\"Gameover!!\")\n      else:\n            print(\"Health is more than 10%, you're safe\")\n</code></pre>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Looping/","title":"Looping","text":"<p>When we want to execute some part of the code multiple times, we use an important programming concept called\u00a0looping\u00a0. There are two types of loops in GDScript:\u00a0for\u00a0loops and\u00a0while\u00a0loops. Let\u2019s explore each of them with examples.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Looping/#for-loop","title":"For Loop","text":"<p>Let\u2019s look at an example of an array that holds the player\u2019s score during each game level, for a total of four levels. This means that the array stores the player\u2019s level 1 score at index 0, level 2 score at index 1, level 3 score at index 2, and level 4 score at index 3. We can use a for loop for iterating through each of these values.</p> <p>To access every item in the array, we define our own variable name that points to the current item. Every time the code inside the loop is executed, this variable then points to the next item in the array. In this way, we can access each of the array elements.</p> <pre><code>extends Node2D\nvar Level_Score = [0,10,40,60]\nvar Total_Score = 0\nfunc _ready():\n      for current_score in Level_Score:\n            Total_Score = current_score + Total_Score\n      print(\"Total score = \", Total_Score)\n</code></pre> <p>In the example given earlier, we first define an array called <code>Level_Score</code> to store the player\u2019s points during each level. We also declare a variable called <code>Total_Score</code> for storing the result of the addition of all the elements in this array. Next, use a for loop with an iterative variable called <code>current_score</code>, which loops through all the array elements, starting from the element at index 0. After a cumulative addition of all the points inside the for loop, we display the result at the output. We can also use for loops for looping through numerical ranges, strings, and even dictionaries.</p> <p>Some other examples of for loops include the following:</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Looping/#1-print-all-the-characters-in-a-string","title":"1. Print all the characters in a string","text":"<pre><code>      func _ready():\n            for ch in \"GODOT\":\n                  print(ch)\n</code></pre> <p>Output</p> <pre><code>G\nO\nD\nO\nT\n</code></pre>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Looping/#2-iterate-over-values-from-num-0-to-4","title":"2. Iterate over values from num = 0 to 4","text":"<pre><code>      func _ready():\n            for n in 5:\n                  print(n)\n</code></pre> <p>Output</p> <pre><code>0\n1\n2\n3\n4\n</code></pre>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Looping/#3-iterate-over-a-range-of-n-10-to-15","title":"3. Iterate over a range of n = 10 to 15","text":"<pre><code>func _ready():\n      for n in range(10,15):\n            print(n)\n</code></pre> <p>Output</p> <pre><code>10 \n11\n12\n13\n14\n</code></pre>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Looping/#4-skip-certain-numbers-in-an-iteration","title":"4. Skip certain numbers in an iteration","text":"<pre><code>func _ready():\n      for n in range(10,20):\n            if(n&lt;=14):\n                  continue # values below 15 are not printed\n            if(n==18):\n                  break # values after 18 are not printed\n            print(n)\n</code></pre> <p>Output</p> <pre><code>15\n16\n</code></pre>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Looping/#5-iterate-over-a-dictionary-and-print-all-the-values","title":"5. Iterate over a dictionary and print all the values","text":"<pre><code>func _ready():\n      var player_points = {\"P1\":10, \"P2\":50, \"P3\":80}\n      print(\"Leaderboard: \")\n      for key in player_points:\n            print(key, \" = \", player_points[key], \" points\")\n</code></pre> <p>Output</p> <pre><code>Leaderboard:\nP1 = 10 points\nP2 = 50 points\nP3 = 80 points\n</code></pre>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Looping/#while-loop","title":"While Loop","text":"<p>We can use\u00a0while\u00a0loops in cases where we have to continuously execute some code until a certain condition is reached. Let\u2019s see an example:</p> <pre><code>extends Node2D\nvar points = 10\nvar total_score = 0\nfunc _ready():\n      while (total_score &lt;= 200):\n            total_score = total_score + points\n            print(\"Total score so far = \", total_score)\n            if(total_score == 100):\n                  print(\"You got 100 points! You won!\")\n                  break\n</code></pre> <p>In the above example, we have written a\u00a0while\u00a0loop for updating the\u00a0<code>total_score</code>\u00a0continuously by cumulatively adding 10 points to it, until\u00a0<code>total_score</code>\u00a0reaches a value of 200. The current value of\u00a0<code>total_score</code>\u00a0is displayed every time 10 more points are added to it. But once the\u00a0<code>total_score</code>\u00a0reaches a value of 100, the\u00a0break\u00a0statement causes the\u00a0while\u00a0loop to end, and the statement, <code>\u201cYou got 100 points! You won!\u201d</code> is displayed in the output.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Operators/","title":"Operators and Computation","text":"<p>Mathematics and logic are the two most essential ingredients of a code written in any programming language. Godot uses simple mathematical, comparison, and logical operators to perform calculations on variables. Let\u2019s take a look at each of them.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Operators/#mathematical-operators","title":"Mathematical Operators","text":"<p>Mathematical operators are used for simple calculations between two or more variables.</p> Operator Symbol Example Addition + <code>var Sum = A + B</code> Subtraction - <code>var Difference = A - B</code> Multiplication * <code>var Multiply = A * B</code> Division / <code>var Divide = A / B</code> Modulo (Remainder) % <code>var Remainder = A % B</code> Square root sqrt <code>var Squareroot_A = sqrt(A)</code>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Operators/#comparison-and-logical-operators","title":"Comparison and Logical Operators","text":"Operator Symbol Condition Description Equal To == <code>A == B</code> True if A is equal to B. Not Equal To != <code>A ! = B</code> True if A is not equal to B. Less Than &lt; <code>A &lt; B</code> True if A is less than B. Greater Than &gt; <code>A &gt; B</code> True if A is greater than B. Less Than or Equal to &lt;= <code>A &lt; = B</code> True if A is either less than B OR equal to B. Greater Than or Equal to &gt;= <code>A &gt; = B</code> True if A is either greater than B OR equal to B. And &amp;&amp; <code>A &amp;&amp; B</code> True if both A and B are true. Or || <code>A \\|         | B</code> Not ! <code>!A</code> If A is false, then return true. If A is true, then return false."},{"location":"Week-2.-Intro-to-Godot/GDScript/Operators/#snippets-of-syntax","title":"SNIPPETS OF SYNTAX","text":"<p>Mathematical Calculations Between Two Variables <code>a</code> and <code>b</code></p> <pre><code>var a = 50\nvar b = 20\nvar sum\nvar difference\nvar multiplication\nvar division\nvar remainder\nvar squareroot_a\nvar squareroot_b\nfunc _ready():\n      print(\"a = \", a)            # Printing the value of a\n      print(\"b = \", b)            # Printing the value of b\n      sum = a + b\n      print(\"sum= \", sum)\n      difference = a - b\n      print(\"difference= \", difference)\n      multiplication = a * b\n      print(\"multiplication = \", multiplication)\n      division = a / b            # a is divided by b\n      print(\"division = \", division)\n      remainder = a % b           # Remainder when a is divided by b\n      print(\"remainder = \", remainder)\n      squareroot_a = sqrt(a)\n      print(\"squareroot of a= \", squareroot_a)\n      squareroot_b = sqrt(b)\n      print(\"squareroot of b= \", squareroot_b)\n</code></pre> <p>Output</p> <pre><code>a = 50\nb = 20\nsum = 70\ndifference = 30\nmultiplication = 1000\ndivision = 2\nremainder = 10\nsquareroot of a = 7.071068\nsquareroot of b = 4.472136\n</code></pre>"},{"location":"Week-2.-Intro-to-Godot/GDScript/RNG/","title":"Random Number Generation","text":"<p>There are tons of uses for a random number when you\u2019re making a game:</p> <ul> <li> <p>Spawning a\u00a0random number\u00a0of enemies during a game level</p> </li> <li> <p>Creating a luck-based computer card game</p> </li> <li> <p>Randomly generating elements in the game world, such as the map</p> </li> <li> <p>Spawning a random collectible or drop when the player beats an enemy</p> </li> </ul> <p>In GDScript, you can generate random numbers using built-in functions that are based on the concept of pseudorandomness. This means that a number is generated using an algorithm and is thus not truly random. You can easily predict the number if you\u2019re familiar with the algorithm, but this is unlikely. To get a random number, we first need to use the predefined function, <code>randomize()</code>, along with another function specific to the type of random number we want. Let\u2019s take a look at how this works.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/RNG/#1-random-integer-generation","title":"1 - Random Integer Generation","text":"<pre><code>func _ready():\n    var random_int = randi()\n    print (random_int)\n</code></pre> <p>Output</p> <p><code>325200109</code></p> <p>The function <code>randi()</code> generates a random integer in the range of 0 to 4,294,967,295. If we want to specify our own range, we can do so in the following way.</p> <pre><code>var rand_generator = RandomNumberGenerator.new()\nfunc _ready():\n    var random_int = rand_generator.randi_range(30, 40)\n    print(random_int)\n</code></pre> <p>Output</p> <p><code>36</code></p> <p>We first have to declare a new random number generator, e.g.,\u00a0<code>rand_generator</code>, and randomize it using the syntax shown earlier. Then, we can use the\u00a0<code>randi_range()</code>\u00a0function\u00a0to specify the range of possible values for our random number. In the case shown earlier, a random integer between 30 and 40 is generated.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/RNG/#2-random-float-generation","title":"2 - Random Float Generation","text":"<pre><code>func _ready():\n    randomize()\n    var random_float = randf()\n    print (random_float)\n</code></pre> <p>Output</p> <p><code>0.278825</code></p> <p>The <code>randf()</code> function generates a random float between 0 and 1. If we want to specify the range of values, we can do it as follows:</p> <pre><code>func _ready():\n      rand_generator.randomize()\n      var random_float = rand_generator.randf_range(-1.5,5.0)\n      print (random_float)\n</code></pre> <p>Output</p> <p><code>4.950228</code></p> <p>Here, we use <code>randf_range()</code> to specify our possible range of float values. The example shown earlier generates a random float value between -1.5 and 5.0.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Variables-and-Data/","title":"Variables and Data Types","text":"<p>A variable is an entity that can store data values. In Godot, it is represented by the keyword\u00a0var. Every variable is associated with a data type that tells us the nature of the stored value. Different data types include integer, float, Boolean, and string. Let\u2019s take a look at them.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Variables-and-Data/#integer","title":"Integer","text":"<ul> <li> <p>An\u00a0integer\u00a0is a whole number and can be positive, negative, or zero.</p> </li> <li> <p>It is represented by the keyword\u00a0int.</p> </li> <li> <p>Examples: 5, 12, 1000, -25, 0, -500</p> </li> </ul>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Variables-and-Data/#float","title":"Float","text":"<ul> <li> <p>A\u00a0float\u00a0is a fractional number that includes a decimal point.</p> </li> <li> <p>It is represented by the keyword\u00a0float.</p> </li> <li> <p>Examples: 5.0, 12.4, 0.0002</p> </li> </ul>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Variables-and-Data/#boolean","title":"Boolean","text":"<ul> <li> <p>Boolean represents two conditions:\u00a0true\u00a0and\u00a0false.</p> </li> <li> <p>It is represented by the keyword\u00a0bool.</p> </li> </ul>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Variables-and-Data/#string","title":"String","text":"<ul> <li> <p>A string represents a word, sentence, or continuous series of characters or numbers enclosed within quotes (\"\").</p> </li> <li> <p>Examples:\u00a0\"M\",\u00a0\"ABCD\",\u00a0\"1234\",\u00a0\"This is a string\"</p> </li> </ul>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Variables-and-Data/#declaring-a-variable","title":"Declaring a Variable","text":"<p>Variables are used to store values that may change throughout your code. You can use them to store data related to your game, such as a player\u2019s score, the current game level, and the speed of an object. To declare a variable, write the keyword <code>var</code>, followed by an identifier, that is, the name you want to give the variable. You can choose to assign a value to the identifier either during variable declaration, or in some other part of the code.</p> <p>In GDScript, identifiers can include any combination of uppercase and lowercase alphabets, an underscore (_), and the digits 0 to 9. Identifiers cannot start with a digit and are case-sensitive. This means you can call a variable <code>Emily1234</code> but not <code>1234Emily</code>. Also, <code>emily</code> and <code>Emily</code> are considered to be two different string values. Here are some examples of variable declarations:</p> <ol> <li> <p><code>var player_name = \"Eva\"</code></p> </li> <li> <p><code>var score = 150</code></p> </li> <li> <p><code>var player_on_ground = true</code></p> </li> <li> <p><code>var distance = 10.5</code></p> </li> <li> <p><code>var total</code></p> </li> </ol>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Variables-and-Data/#explicit-and-inferred-typing","title":"Explicit and Inferred Typing","text":"<p>When declaring a\u00a0variable, you can choose to specify its type optionally.</p> <p>Here are some examples:</p> <ol> <li> <p><code>var fruit: String = \"Pineapple\"</code></p> </li> <li> <p><code>var fruit = \"Pineapple\"</code></p> </li> </ol> <p>In each of these cases, you store a string called\u00a0\"Pineapple\"\u00a0in the variable\u00a0<code>fruit</code>. But in the first case, you directly state that the value you are storing is a string, while in the second case, this is inferred. The first method is called\u00a0explicit\u00a0typing, while the second is called\u00a0inferred\u00a0typing.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Variables-and-Data/#constants","title":"Constants","text":"<p>Constants\u00a0are values that don\u2019t change when you run a game. When you declare a variable as a constant, its value stays the same throughout the code, and it can\u2019t be assigned any other value.</p> <p>Here\u2019s an example:</p> <p><code>const LENGTH = 10</code></p> <p><code>const SPEED: int = 100</code></p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Variables-and-Data/#enums","title":"Enums","text":"<p>An\u00a0enum\u00a0is a group of constants and can be useful when you want each constant to be\u00a0associated\u00a0with a consecutive integer. An enum can be written in multiple ways. Here are some examples:</p> <ol> <li> <p><code>gdscript    const CIRCLE = 0    const SQUARE = 1    const RECTANGLE = 2    const TRIANGLE = 3</code></p> </li> <li> <p>This can also be written as:</p> </li> </ol> <pre><code>enum Shapes = {CIRCLE, SQUARE, RECTANGLE, TRIANGLE}\nconst Player = {IDLE = 0, RUN = 3, JUMP = 4}\n</code></pre> <p>Which can also be written as:</p> <pre><code>enum Player {IDLE, RUN = 3, JUMP}\n</code></pre> <p>Values can be accessed by <code>Player.IDLE</code>, <code>Player.RUN</code>, <code>Player.JUMP</code>.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Variables-and-Data/#keywords","title":"Keywords","text":"<p>Every programming language has specific words called\u00a0keywords\u00a0that are reserved. These should not be used as identifiers, as they hold a special meaning to the compiler. The following are some of the popular keywords of GDScript:</p> <code>if</code> <code>elif</code> <code>else</code> <code>for</code> <code>while</code> <code>match</code> <code>break</code> <code>continue</code> <code>pass</code> <code>return</code> <code>class_name</code> <code>extends</code> <code>var</code> <code>const</code> <code>enum</code> <code>func</code> <code>static</code> <code>onready</code> <code>export</code> <code>signal</code> <code>is</code> <code>as</code> <code>self</code> <code>tool</code> <p>You can read more about these keywords from Godots official documentation on it.</p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Variables-and-Data/#comments","title":"Comments","text":"<p>When you want to add comments in your\u00a0code, you can do so by writing\u00a0<code>#</code>\u00a0followed by the comment. These are ignored by the engine.</p> <p><code># This is an example of a comment</code></p>"},{"location":"Week-2.-Intro-to-Godot/GDScript/Variables-and-Data/#output","title":"Output","text":"<p>When you want to display a message or a variable value in the output, you can use the\u00a0print\u00a0statement. You have to specify the text to be displayed within the quotation marks and the variable value to be displayed after a\u00a0comma. Examples include the following:</p> <ol> <li> <p><code>print(\"This is being displayed at the output!\")</code></p> </li> <li> <p><code>print(\"The total Sum= \",sum)</code></p> </li> <li> <p><code>print(my_variable)</code></p> </li> </ol>"}]}