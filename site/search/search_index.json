{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Google Developer Groups (GDG) \u2014 IAU \u2014 Game Development Track","text":""},{"location":"#welcome-to-gdg-iau","title":"Welcome to GDG IAU!","text":"<p>Welcome to the Game Development track of the Google Developer Groups (GDG) club at the Imam Abdulrahman Bin Faisal University (IAU). Our main focus is to train and prepare students to develop their own games, and help kick-off their career in game development.</p>"},{"location":"#about-us","title":"About Us","text":"<p>We're a group of passionate game developers eager to help others learn more about the wonders of game development and help develop their knowledge and skills. We try to create educational content that's fitting for both experienced developers and novices. Whether you're a seasoned expert of game development, or just starting your journey, there's a place for you here.</p>"},{"location":"#what-to-expect","title":"What To Expect","text":"<p>We have created a 4-5 week course for aspiring game developers of the club to participate in. Each week will focus on a set of game development concepts and will have tutorials and live sessions to help develop the students skills. In addition to the general course, a group of students will be specially selected to partake in \"focus group\" teams that will receive direct mentorship from the track's leaders and assistance in creating a demo for their own, unique game.</p>"},{"location":"Week-1.-Making-Your-First-Game/","title":"Introduction","text":""},{"location":"Week-1.-Making-Your-First-Game/#welcome","title":"Welcome!","text":"<p>Welcome to the first week of the game development track! In this week, we will discuss the bare basics of game development. Starting from just the simple definition of a game, moving onto the reality of how video games actually work, and finally making our own first game to top it off.</p>"},{"location":"Week-1.-Making-Your-First-Game/#what-is-a-game","title":"What is a game?","text":"<p>Most of us have a pretty intuitive notion of a game, right? The word \"game\" can include games such as Monopoly or Chess.</p> <p>We can say that a game is a structured activity where players can make decisions and take actions within the rules of a game to achieve a specified goal, and they can either win or lose in doing that.</p> <p>When it comes to video games however, we typically think of virtual worlds. With many characters, objects, and environments. And this is true. Despite this however, a video game is still a game, and the same principles of ordinary games apply.</p> <p>There are many different types of games. They are classified by genres, and often along the gameplay style, rules, themes, and other elements.</p> <p></p>"},{"location":"Week-1.-Making-Your-First-Game/#video-games","title":"Video Games","text":"<p>Video games - as software - all have some common components to them. Almost every game has, at least some of:</p> <ul> <li> <p>A Graphics System: Responsible for displaying graphics to the screen.</p> </li> <li> <p>An Audio System: Responsible for audio and playing sounds of the game.</p> </li> <li> <p>A Physics System: Responsible for physics of players and objects.</p> </li> <li> <p>An Input System: Takes in the input of the player (keyboards, controllers, etc...)</p> </li> <li> <p>Game Logic: A logic and set of rules dictating the state of the game and what the player can and cannot do, and how the game state responds to player input.</p> </li> <li> <p>Many Other Components...</p> </li> </ul> <p>When we look at all these technical components that make up a video game, they are plentiful, but they all work together to create one, coherent experience for the player. Thus we can say that video games are the interplay of many technical components, to produce a player experience with rules and constraints that can be won or lost.</p> <p></p>"},{"location":"Week-1.-Making-Your-First-Game/#the-game-loop","title":"The Game Loop","text":"<p>We mentioned that video games are comprised of many technical components. All of these components are updated in a fixed \"loop\" throughout the entirety of the game, called the \"game loop\".</p> <p></p> <p>The game loop first processes player input (such as from the keyboard, mouse movements, or buttons pressed on a controller), then updates the game state based on this input and other variables, finally it draws (renders) this state visually to the screen. This process repeats itself ad infinitum (forever) until the game ends.</p> <p>Example Game Loop Code</p> <pre><code>int main()\n{\n\u00a0\u00a0\u00a0\u00a0// Initializing the technical components / subsystems\n\u00a0\u00a0\u00a0\u00a0InitGame();\n\n\u00a0\u00a0\u00a0\u00a0// The game loop, it repeats continuously until the game ends\n\u00a0\u00a0\u00a0\u00a0while (GameIsRunning)\n\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0// ====== NEW FRAME ======\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Operating system work is done here\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Receiving input from keyboard-mouse-controller\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// And checking OS events (did the window close? or minimize? etc)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Not the subject of our focus for this track\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ProcessInput();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// The actual game's state\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// (players position and health, enemies, inventory, etc...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// is updated here\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0UpdateGame();\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// The game's state is rendered (drawn) to the screen graphically here\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0RenderGame();\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// ====== END OF FRAME ======\n\u00a0\u00a0\u00a0\u00a0}\n\n\u00a0\u00a0\u00a0\u00a0// We exitted the loop (GameIsRunning == false)\n\u00a0\u00a0\u00a0\u00a0// Quit the game\n\u00a0\u00a0\u00a0\u00a0ExitGame()\n}\n</code></pre> <p>Effectively, all video games run in one big <code>while</code> loop. The number of times a loop is completed in one second is called the \"frames per second\" (FPS) of a game. \"Frame\" refers to the visual output of the game to the screen, the final step of the loop before repeating. Generally, a higher FPS means a smoother experience for the player.</p>"},{"location":"Week-1.-Making-Your-First-Game/#pong","title":"Pong","text":"<p>Pong is the first video game ever made, it's basically an extremely simple top-down tennis of sorts. Here is some footage of the gameplay and an example of what the game's loop would look like.</p> <p></p> <p>Example Pong Game Code</p> <pre><code>while (GameIsRunning)\n{\n    // ===== NEW FRAME =====\n\n    ProcessInput();\n\n    if (QuitButtonPressed())\n    {\n        GameIsRunning = false;\n    }\n\n    MovePaddles();\n\n    MoveBall();\n\n    CheckBallCollisionsAndBounce();\n\n    if (BallImpactedSide(LEFT_PLAYER))\n    {\n        IncrementScore(RIGHT_PLAYER);\n        ResetBall();\n    }\n    if (BallImpactedSide(RIGHT_PLAYER))\n    {\n        IncrementScore(LEFT_PLAYER);\n        ResetBall();\n    }\n\n    RenderPlayfield();\n\n    // ===== END OF FRAME =====\n}\n</code></pre> <p>On a more granular level, this is an example of what each frame of the game would look like as it's being updated. Remember that \"update\" here just means that we're repeating this loop once again.</p> <p></p>"},{"location":"Week-1.-Making-Your-First-Game/#making-our-own-game","title":"Making our Own Game","text":"<p>Don't worry if you don't understand all of this just yet. In the next section of this week, we will get started on actually trying to create pong for ourselves using Raylib and C++. If you don't understand anything about the example code for Pong, you'll understand it soon enough when you follow the tutorial.</p> <p>The important thing to take away from this section is this:</p> <ul> <li> <p>Video games run in a fixed loop, called the game loop</p> </li> <li> <p>This loop updates the state of the game, and draws it to the screen graphically, then repeats that process until the game is over</p> </li> <li> <p>The game is comprised of many technical components, all of which are updated in the loop and play a role in completing the game experience for the player</p> </li> </ul>"},{"location":"Week-1.-Making-Your-First-Game/1-Setting-Up/","title":"1. Getting Started","text":"<p>This is the setup section of this tutorial. It's really much simpler than you'd expect, but if you'd like to skip this section, ready versions of the final set-up will be provided for Windows and MacOS.</p>"},{"location":"Week-1.-Making-Your-First-Game/1-Setting-Up/#making-the-build-system","title":"Making the Build System","text":"<p>To get started, let's make a folder called \"Pong\", and create a file in it called \"pong.cpp\". The \".cpp\" file extension stands for C++.</p> <p></p> <p>Inside the file we'll just put a hello world program for now.</p> <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    std::cout &lt;&lt; \"Hello World\\n\";\n    return 0;\n}\n</code></pre> <p>One way to actually run this code is to use the standard C/C++ VSCode extension, in this tutorial however, we'll be invoking the compiler directly in the command-line. Make sure you have the GCC compiler installed on your device, and in your path (resources will be provided for this later). Open CMD (or whichever terminal you prefer), go to the folder we just created, and write <code>g++ pong.cpp -o pong.exe</code>.</p> <p></p> <p>This will invoke the G++ compiler, compile the file <code>pong.cpp</code> and link it into the output executable <code>pong.exe</code>. There should now be a <code>pong.exe</code> file in our new folder.</p> <p></p> <p>If you run it from the CMD by just typing <code>pong.exe</code>, it will run our Hello World program.</p> <p></p> <p>Having to write out the compile command everytime we want to compile is tiresome though, so instead of doing that we will write a shell script that will just execute the command for us. In our new folder, let's create a file called <code>build.bat</code>.</p> <p></p> <p>This is the file that contains our compile command, for now let's just put the command we used earlier on it.</p> <pre><code>g++ pong.cpp -o pong.exe\n</code></pre> <p>If we just call this script now in our terminal, it will automatically type out the command written inside it.</p> <p></p> <p>The second line is typed out automatically. If you don't want for it to be visible however, just type out a <code>@</code> in the beginning of the line where your command is.</p> <pre><code>@g++ pong.cpp -o pong.exe\n</code></pre> <p>Now, it should just execute the compile command without echoing it in the terminal.</p> <p></p> <p>To verify that it's working, let's add a message in our program, build it, then run it to check that it is indeed working correctly.</p> <pre><code>    std::cout &lt;&lt; \"Hello World\\n\";\n    std::cout &lt;&lt; \"This is our first game in GDG!\\n\";\n</code></pre> <p>Let's save it and check.</p> <p></p> <p>Now let's setup Raylib for this project. The process is as simple as adding a couple of flags to our <code>build.bat</code> file, and copying a few files to our Pong folder.</p>"},{"location":"Week-1.-Making-Your-First-Game/1-Setting-Up/#setting-up-raylib","title":"Setting up Raylib","text":"<p>In order to setup Raylib, there are really only 2 things we need to do:</p> <ul> <li> <p>Add a header folder and file, and include them in the compile command</p> </li> <li> <p>Add the actual library itself and link it in the compile command</p> </li> </ul> <p>In total, they're just 2 files, 1 library and 1 header. There will be a link to download these files. Just copy them in your folder like so:</p> <p></p> <p>Now, let's update our build script to account for these inclusions.</p> <pre><code>@g++ pong.cpp -o pong.exe -I include\n</code></pre> <p>Now, if we update our main source file to include <code>raylib.h</code>, it should work fine once we compile it.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;raylib.h&gt;\n</code></pre> <p>Let's compile.</p> <p></p> <p>Great! There are no errors. Here's what we would've got if we didn't put <code>-I include</code> in our build file:</p> <p></p> <p>The <code>-I include</code> command basically tells the compiler to search within the provided directory for header files, in this case it's searching through our \"include\" folder to find <code>raylib.h</code>.</p> <p>Now, let's try to actually call a method found in <code>raylib.h</code> in our file. Let's use the most simple method, <code>InitWindow()</code>. As you might expect, this is just a function that creates a window for our game. It takes in three parameters: <code>width</code>, <code>height</code>, and <code>title</code>. For our purposes, we'll make our game a fixed 1280x720 and call it \"pong\".</p> <pre><code>    std::cout &lt;&lt; \"Hello World\\n\";\n    std::cout &lt;&lt; \"This is our first game in GDG!\\n\";\n    InitWindow(1280, 720, \"Pong\");\n</code></pre> <p>If we try to run the code now however, we'll get some strange errors:</p> <p></p> <p>This is GNU's idea of a linker error. It's long and protracted but basically, what it's trying to tell is us is that the <code>InitWindow()</code> function we're trying to call doesn't actually have an implementation available to it that it can execute. G++ knows the function exists because it's found in <code>raylib.h</code>, but it doesn't know what it actually does because the header file doesn't contain the implementation for the function. Instead, the implementation is available to us in the \"lib\" folder we downloaded from earlier.</p> <p></p> <p>In here we'll find this <code>libraylib.a</code> file.</p> <p></p> <p>This file contains the implementations of all the functions found in <code>raylib.h</code>, what we need to do now is to link it in our compile command:</p> <pre><code>@g++ pong.cpp -o pong.exe -I include -L lib -l raylib\n</code></pre> <p>The <code>-L lib</code> flag is similar to the <code>-I</code> one, it tells the compiler the directory to search through when looking for libraries to link, in this case it's the \"lib\" directory. The <code>-l raylib</code> flag tells the compiler to link the <code>libraylib.a</code> file inside the lib folder from earlier, the first 3 letters \"lib\" and the file extension \".a\" are not included when invoking this flag for some reason (GNU is weird).</p> <p>Let's try running it now:</p> <p></p> <p>Woah! Now that is a lot of linker errors. Don't fret though. All of these linker errors is because we didn't link the libraries of the actual operating system yet. You see, <code>InitWindow()</code> creates a window for our game to run in, in order for it to do that though, it needs to work with the operating system for it to actually get that window. In our case, the operating system is Windows, and there are actually a few Windows libraries we need to link before we can say that all the necessary libraries are linked to our program. So let's go ahead and include them.</p> <pre><code>@g++ pong.cpp -o pong.exe -I include -L lib -l raylib -l gdi32 -l opengl32 -l winmm\n</code></pre> <p>Now that's quite a lot of libraries. You don't need to know the details, but if you're curious, the libraries we linked are:</p> <ul> <li> <p><code>gdi32</code>: The Windows Graphics Device Interface, for creating our window</p> </li> <li> <p><code>opengl32</code>: The Open Graphics Library, for rendering our graphics</p> </li> <li> <p><code>winmm</code>: The Windows MultiMedia API, for audio stuff</p> </li> </ul> <p>Now, if we try to build, it should work just fine.</p> <p></p> <p>It works! However, if we try running it, something odd happens.</p> <p></p> <p>A bunch of Raylib Info lines show up, and a window momentarily appears and disappears, why does this happen? It's because after we Initialize our Window, there's nothing else left for the program to do, so it just shuts down.</p> <p>Don't worry about that for now. Right now, we've completed the setup section! Now we can move on to actually programming the game.</p>"},{"location":"Week-1.-Making-Your-First-Game/2-The-Game-Loop/","title":"2. The Game Loop","text":"<p>In the previous section of this tutorial, we setup our projects dependencies and build \"system\". Now, we'll actually get to programming the game itself, starting with the game loop.</p>"},{"location":"Week-1.-Making-Your-First-Game/2-The-Game-Loop/#the-game-loop","title":"The Game Loop","text":"<p>In our earlier sections, we discussed the basic idea of the game loop. Now we get to see what that looks like in code. Once we remove our <code>std::cout</code> lines, this is what our code looks like now:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;raylib.h&gt;\n\nint main()\n{\n    InitWindow(1280, 720, \"Pong\");\n    return 0;\n}\n</code></pre> <p>We can see that after the <code>InitWindow</code> call, there's no other code to execute, and the program returns. In order to stop this and actually have a program running, we need to create a loop. Theoretically, a <code>while (true)</code> loop could suffice, however in Raylib, there's a function called <code>WindowShouldClose()</code> that returns a boolean. We'll use this boolean as the condition for our loop instead, such that if the return value is <code>false</code>, then we know that nothing has been done to make the window close, and our program should continue executing.</p> <pre><code>    InitWindow(1280, 720, \"Pong\");\n\n    while (!WindowShouldClose())\n    {\n    }\n</code></pre> <p>The difference between this approach and the <code>while (true)</code> one is that for this one, certain events can take place that will actually effect the condition. For example, if we press the big red \"X\" on the top right corner of the window, this variable will switch to true, and our program will close. Another condition that will by default effect this variable is if we press the escape key. Pressing escape will shutdown our program by default.</p> <p>If we try to run it now, we get a window! However, it's unresponsive.</p> <p></p> <p>The reason for this is that throughout the loop that's repeating itself, our program is not interacting with the operating system at all. Raylib provides functions that do this directly, such as <code>PollInputEvents()</code>, this is for advanced users however. In Raylib, the polling of OS events happens in tandem with the rendering functions, so if we just create a simple rendering loop this problem will resolve itself just fine.</p>"},{"location":"Week-1.-Making-Your-First-Game/2-The-Game-Loop/#rendering-graphics","title":"Rendering Graphics","text":"<p>The graphics functions mostly operate in their own \"phase\" of sorts. The beginning and end of this phase are marked by the <code>BeginDrawing()</code> and <code>EndDrawing()</code> functions. If we place them in order in our loop, our program will become responsive.</p> <pre><code>    while (!WindowShouldClose())\n    {\n        BeginDrawing();\n        // All of our graphics stuff happens here!\n        EndDrawing();\n    }\n</code></pre> <p>If we run it now, we'll get this:</p> <p></p> <p>We finally have a fully working, proper, honest window on our hands. We can move it around, minimize it, and even close it. One thing we can't do yet is resize it, but that's intentional, to make the process of actually making our game simpler.</p> <p>Let's try actually drawing something on the screen for real this time. In Raylib, there's a function called <code>DrawRectangle()</code> that takes in 5 arguments. <code>posX, posY, width, height, color</code>. In both Raylib and Godot, the origin of a rectangle is the top-left corner, and the rectangle expands rightwards and downwards according to the width and height.</p> <p></p> <p>So, in our code, let's just a draw a red square with the origin points (0, 0) and a 40x40 size.</p> <pre><code>    while (!WindowShouldClose())\n    {\n        BeginDrawing();\n        DrawRectangle(0, 0, 40, 40, RED);\n        EndDrawing();\n    }\n</code></pre> <p>If we run it now, we'll see a red square at the top left corner of our screen:</p> <p></p> <p>The reason the square is showing up on the top left corner of the screen is because right now, the origin of the coordinate system is mapped to the top-left corner. This would be a good time to talk about coordinate systems.</p>"},{"location":"Week-1.-Making-Your-First-Game/2-The-Game-Loop/#coordinate-systems","title":"Coordinate Systems","text":"<p>Maths are a very common element of video game programming that you need to intuitively understand if you want to confidently develop your ideas into games. The maths required in game development is not that difficult or complicated, and in general you'll find you'll get better at it the more you do it.</p> <p>The first thing you should understand is coordinate systems. You might be familiar with this setup:</p> <p>You should all be familiar with this from high school. You have an X-axis and a Y-axis. The grid here represents all the points that you can represent in two-dimensions. Each square being one unit, right is positive on the X-axis, left is negative... basically no different from when you remember it.</p> <p>Well, no. Actually there is one difference between the systems in Raylib and Godot and from the coordinate systems you're all familiar with. In Raylib and Godot, up is negative on the Y-axis, and down is positive. So if we filled out the numbers it would look something like this.</p> <p>Moreover, the origin point (0, 0) is in the center. But in our current setup (in-game), the origin point is in the top left, and the width and height of the grid correspond to the screen width and height that we set. In other words, each unit in the grid is 1 pixel.</p> <p></p> <p>In this illustration, each grid square is obviously not one pixel because it's not scaled correctly, but this is just an example. When you look at it, and keeping in mind that rectangle coordinate systems follow the same pattern of having the origin at the top-left, it becomes clear why our call to the <code>DrawRectangle()</code> function caused it to appear where it did. (0, 0) is the top-left, and the square itself is goes 40 pixels to the right and 40 pixels down from the origin. If we stretched the width to 1280, same as the screen width, then it will appear as a big red strip on covering the top-most part of our screen.</p> <pre><code>        DrawRectangle(0, 0, 1280, 40, RED);\n</code></pre> <p></p> <p>Same with the height.</p> <pre><code>        DrawRectangle(0, 0, 40, 720, RED);\n</code></pre> <p></p> <p>Let's try placing the square right in the center of our screen. We know the right side is 1280, and the left side is 0, so logically the middle is between those two points , \\({(0+1280)\\over{2}}=640\\). Likewise with the height, \\({(0+720)\\over{2}}=360\\). So lets try placing our 40x40 square there.</p> <pre><code>        DrawRectangle(640, 360, 40, 40, RED);\n</code></pre> <p></p> <p>And there it is! You'll notice that it's not exactly in the center, rather, the top-left corner of the square is in the center. If we want the center of the square to be in the center of the screen we'd have to displace it up and to the left 20 units. But that's not necessary, what's important now is that you understand this concept of the coordinate system because it'll be really important for your game development journey.</p>"},{"location":"Week-1.-Making-Your-First-Game/2-The-Game-Loop/#moving-the-square","title":"Moving the Square","text":"<p>Having a square appear where we want it to be is cool and all, but it'd be nicer if we could actually move the square. Moving the square is really as simple as just moving the position of the square <code>posX, posY</code>. But how do we actually do that? Well first, we must take input from the user.</p> <p>Raylib has several functions for receiving input from the user, but the ones we're interested in right now are <code>IsKeyPressed()</code> <code>IsKeyDown()</code> and <code>IsKeyReleased()</code>. Each of these functions takes in a keycode as an argument, and returns a boolean.</p> <ul> <li> <p><code>IsKeyPressed()</code> returns true if the key was just pressed at that moment.</p> </li> <li> <p><code>IsKeyDown()</code> returns true if the key is held down at any moment.</p> </li> <li> <p><code>IsKeyReleased()</code>returns true if the key was just released at that moment.</p> </li> </ul> <p>Note</p> <p>In Godot \u2014 the engine we'll be using \u2014 the functions for checking input are mostly the same; there are distinctions between having just pressed a key, holding a key down, and having just released a key.</p> <p>Let's write something simple for now, let's make a program that changes the color of our square to green if the user pressed the space bar:</p> <pre><code>    Color square_color = RED;\n\n    while (!WindowShouldClose())\n    {\n        if (IsKeyPressed(KEY_SPACE))\n        {\n            square_color = GREEN;\n        }\n\n        BeginDrawing();\n        DrawRectangle(640, 360, 40, 40, square_color);\n        EndDrawing();\n    }\n</code></pre> <p>If we run the program now, the color of the square will be initially red:</p> <p></p> <p>But if we press space...</p> <p></p> <p>It turns green! This is the first example you'll see of non-graphics state being rendered in visual form. The <code>square_color</code> variable is affected by user input, and it's also used in the drawing phase of our program. If we want our square to move according to user input, we need to do something similar but this time with the player's position.</p> <pre><code>    Vector2 player_position = { 640, 360 };\n\n    while (!WindowShouldClose())\n    {\n        if (IsKeyPressed(KEY_RIGHT))\n        {\n            player_position.x += 40;\n        }\n\n        BeginDrawing();\n        DrawRectangle(player_position.x, player_position.y, 40, 40, RED);\n        EndDrawing();\n    }\n</code></pre> <p>What we've done here is used a <code>Vector2</code> struct, which is just a container for 2 floats <code>x</code> and <code>y</code>, to represent the player's position. We're then taking the right arrow key being pressed (KEY_RIGHT) as a sign to move the player 40 units to the right. Finally, in the <code>DrawRectangle()</code> call, we're substituting our initial constant values (640, 360) for the <code>player_position</code> variable. If all goes well, when we press the right arrow key, the player should move to the right.</p> About Vectors... <p>In game programming, the idea of a \"vector\" is quite versatile. From a sheer programming perspective, it's just a container for floats representing coordinates in a certain space, they can be two coordinates <code>x</code> and <code>y</code>, denoting a <code>Vector2</code>. Or they can be three coordinates, <code>x</code>, <code>y</code> and <code>z</code>, denoting a <code>Vector3</code>. In practice however, a vector can represent many things, they are most commonly used to represent points in a space, or an actual direction and magnitude in the conventional physics definition of a vector.</p> <p>Both concepts are used extensively in game programming, and are both represented with the same data type, <code>Vector</code>. To learn more about this topic, we recommend following this YouTube series on math for game developers. It's highly accessible and valuable.</p> <p></p> <p>Well, that's strange! The square seems to have stretched 40 units to the right and has become a rectangle. Did we make a mistake? No. Well, not in the state code anyways. </p> <p>You see, when rendering graphics, we need to make sure we're rendering the current state exclusively, and not the previous frames' state. In here, we have the state before we pressed right, and the state after pressing the right arrow key. Because we're not clearing the screen of the original state's visual output, the new visual output and old ones have been merged together. A combination of Frame 1 + Frame 2. The current order of rendering looks like this:</p> <ul> <li> <p>Draw red square at <code>(640, 360)</code></p> </li> <li> <p>Present to the screen</p> </li> <li> <p>== NEW FRAME ==</p> </li> <li> <p>Draw red square at <code>(640, 400)</code></p> </li> <li> <p>Present to the screen</p> </li> </ul> <p>All that we need to do to fix this is to just clear the screen of whatever graphics we rendered to it before we render the new graphics. In Raylib, the function for this is called <code>ClearBackground()</code>. Let's choose black for now as our clear color.</p> <pre><code>    Vector2 player_position = { 640, 360 };\n\n    while (!WindowShouldClose())\n    {\n        if (IsKeyPressed(KEY_RIGHT))\n        {\n            player_position.x += 40;\n        }\n\n        ClearBackground(BLACK);\n        BeginDrawing();\n        DrawRectangle(player_position.x, player_position.y, 40, 40, RED);\n        EndDrawing();\n    }\n</code></pre> <p>Now that we're clearing the screen \u2014 effectively erasing all the contents of it \u2014 before we draw in it, our order of rendering looks more like this.</p> <ul> <li> <p>Clear the screen</p> </li> <li> <p>Draw red square at <code>(640, 360)</code></p> </li> <li> <p>Present to the screen</p> </li> <li> <p>== NEW FRAME == </p> </li> <li> <p>Clear the screen</p> </li> <li> <p>Draw red square at <code>(640, 400)</code></p> </li> <li> <p>Present to the screen</p> </li> </ul> <p>Let's run it now and move right 3 times.</p> <p></p> <p>That's more like it. Now, let's try duplicating the logic for this across all 4 directions.</p> <pre><code>        if (IsKeyPressed(KEY_RIGHT))\n        {\n            player_position.x += 40;\n        }\n        if (IsKeyPressed(KEY_LEFT))\n        {\n            player_position.x -= 40;\n        }\n        if (IsKeyPressed(KEY_UP))\n        {\n            player_position.y -= 40;\n        }\n        if (IsKeyPressed(KEY_DOWN))\n        {\n            player_position.y += 40;\n        }\n</code></pre> <p>If we run it:</p> <p></p> <p>It finally works! We have our own player of sorts now.</p>"},{"location":"Week-1.-Making-Your-First-Game/2-The-Game-Loop/#continuous-movement","title":"Continuous Movement","text":"<p>You'll notice that currently our movement is discrete. We move 40 units, every time we press an arrow key. But we'd rather have our movement be continuous; we don't want to move just once when we press a key, we want to move continuously as we're holding a key down.</p> <p>To do this, we just need to change the function we're using <code>IsKeyPressed()</code> to the more appropriate <code>IsKeyDown()</code> instead, which will return <code>true</code> as we're holding a key down.</p> <pre><code>        if (IsKeyDown(KEY_RIGHT))\n        {\n            player_position.x += 40;\n        }\n        if (IsKeyDown(KEY_LEFT))\n        {\n            player_position.x -= 40;\n        }\n        if (IsKeyDown(KEY_UP))\n        {\n            player_position.y -= 40;\n        }\n        if (IsKeyDown(KEY_DOWN))\n        {\n            player_position.y += 40;\n        }\n</code></pre> <p>If we run it now, we can see that it kinda works, but something's off.</p> <p></p> <p>In the GIF it's a little choppy, but that's only because it's at 30 fps. Putting that aside, our player is moving way too fast. How come? Well, when we look at the code again, we can see that we're moving 40 pixels at once everytime the player moves, also, we check for input every loop (frame), so if we hold the key down, what this effectively means is we're moving 40 pixels each frame, which is obviously more than we'd want. What we'd like to have instead is to have the player move 40 pixels per second, which is totally different from 40 pixels per frame.</p> <p>We know at this point that the amount of times the game loop is executed in one second is known as the frames per second of our game (FPS), the \"frame\" in this context refers to the visual output to the screen, which is the final part of the game loop if you'd remember. However, we're going to use the term \"frame\" here to refer to the execution of the game loop in its entirety, and not just the literal visual output on the screen, which is common in game development.</p> <p>Since we're doing this movement each frame, it stands to reason that if we increase or decrease the FPS of our game the speed of the movement will follow suit. You can experiment with this and see that it's true.</p> <p>We can demonstrate this mathematically. If we add 40 to position per frame @ 60 FPS, we'll have a total displacement of 2400 per second.</p> <p></p> <p>If we try set our FPS to 120, or just demonstrate this mathematically again, we can see that the total displacement per second changes.</p> <p></p> <p>This is obviously a big problem, since we don't want something like our movement speed to be dependent on the game's FPS, as this can cause undesired and unpredictable behavior, and can give some players advantages over others depending on what FPS their machine can or cannot handle.</p> <p>In Raylib, there's a function called <code>SetTargetFPS()</code> to set the FPS for us. By default the target FPS is set to match the current monitor's refresh rate, but for the sake of consistency let's just set the target FPS to 60 before the initialization of our window.</p> <pre><code>    SetTargetFPS(60);\n    InitWindow(1280, 720, \"Pong\");\n</code></pre>"},{"location":"Week-1.-Making-Your-First-Game/2-The-Game-Loop/#delta-time","title":"Delta Time","text":"<p>Well now that we know why our player is moving much faster than we'd like, what's the solution? Since the reason for the high speed is because it's correlated to the frames of our game, what we need to do is find some way to decouple our game's logic from the FPS. In order to do this, we need to take the delta time of our game, also known as the frame time, and multiply it by all variables which we want to be per second rather than per frame.</p> <p>That's quite a lot to take in, but let's break it down. The delta time (frame time), as you may tell, is just simply the amount of time it takes to execute one frame or loop of our game. If the frames per second tells us how many frames are done per second, this is the complete opposite, it tells us how many seconds it takes to do one frame. We can get the delta time by dividing 1 by the FPS. For 60 FPS, the frame time is 0.01666 seconds, or 16.66 miliseconds, equivalent to \\(1\\over60\\).</p> Real delta time <p>In real games, the delta time is actually acquired manually, by taking the time (in seconds) at the current frame, and subtracting from the time of the previous frame.</p> <p><code>delta_time = current_time - previous_frame_time</code></p> <p>So what happens when we multiply this number by our time-dependent variables? What happens is the 40 units we wanted to move per second, are in-fact being moved per-frame but at a much slower rate than 40. How much slower? Just slow enough for it to complete 40 units by the time 1 second passes.</p> <p>We can illustrate this demonstration again for 60 FPS.</p> <p></p> <p>As you can see, the total displacement per second now is at around 40, which is our desired result. Just as importantly, if we test this on a different FPS like 120, our end result remains the same.</p> <p></p> <p>We can prove that the total displacement per seconds will always be the same regardless of the current FPS using this method mathematically. If \\(40\\) is our desired per second displacement, and we are displacing at a rate of \\(60\\) frames per second, multiplying by delta time is the same as dividing \\(40\\) by \\(60\\), and we're displacing \\(60\\) times in one second so the total displacement in seconds would look like:</p> <p>\\({40\\over60}\\times60=40\\)</p> <p>The division by 60 and multiplication by 60 cancel each other out, leaving only 40. This is obviously true for other FPS rates as well.</p> <p>Note</p> <p>This solution is not perfect. Games that require a lot of precision such as online games or fighting games need more precise solutions for decoupling FPS and game logic, and we will cover a few of them later on.</p> <p>This solution however is good enough for most cases, and it's what we'll be using for now. </p> <p>In Raylib, the function for acquiring the frame time is simply called <code>GetFrameTime()</code>, let's go ahead and store it first thing in our loop.</p> <pre><code>    while (!WindowShouldClose())\n    {\n        float delta_time = GetFrameTime();\n    \u00a0\u00a0\u00a0\u00a0...\n    \u00a0\u00a0\u00a0\u00a0...\n    }\n</code></pre> <p>Now let's take all the instances of us translating the player position by 40 units and multiply it by our delta time.</p> <pre><code>        float delta_time = GetFrameTime();\n        if (IsKeyDown(KEY_RIGHT))\n        {\n            player_position.x += 40 * delta_time;\n        }\n        if (IsKeyDown(KEY_LEFT))\n        {\n            player_position.x -= 40 * delta_time;\n        }\n        if (IsKeyDown(KEY_UP))\n        {\n            player_position.y -= 40 * delta_time;\n        }\n        if (IsKeyDown(KEY_DOWN))\n        {\n            player_position.y += 40 * delta_time;\n        }\n</code></pre> <p>And let's see what we get:</p> <p></p> <p>Well it's rather slow, but then again 40 pixels per second isn't that fast to begin with. What's important is that it works! Now that we got that out of the way we can actually begin to work on our game.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/","title":"3. Making Pong","text":""},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#structure","title":"Structure","text":"<p>The game that we're gonna be making is Pong, the first video game made.</p> <p></p> <p>There is a ball in the middle, and two paddles. The ball goes to one paddle which then hits it, and sends it back to the other paddle, if one of them fails to hit and enters their goal, that's a score for the other paddle. Really an extremely simple game.</p> <p>What we should first do is define the structure when we're making it. In this case, there are just a few elements we have to consider:</p> <ul> <li> <p>There are two paddles</p> </li> <li> <p>1 left and 1 right</p> </li> <li> <p>They can only go up and down</p> </li> <li> <p>They can hit the ball to bounce it off to the other end</p> </li> <li> <p>There's a ball</p> </li> <li> <p>It bounces off the top and bottom of the screen</p> </li> <li> <p>It bounces off the paddles</p> </li> <li> <p>If it enters a paddle's goal then it's a score for the other paddle</p> </li> <li> <p>If a goal is scored the ball and paddles are both reset to the center</p> </li> <li> <p>There is text on the top part of the screen of the paddles' scores</p> </li> </ul> <p>Let's do some housekeeping with our current code before we move any further:</p> <pre><code>const int SCREEN_WIDTH = 1280;\nconst int SCREEN_HEIGHT = 720;\n\nint main()\n{\n    SetTargetFPS(60);\n    InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, \"Pong\");\n\n    while (!WindowShouldClose())\n    {\n        float delta_time = GetFrameTime();\n\n        ClearBackground(BLACK);\n        BeginDrawing();\n        EndDrawing();\n    }\n</code></pre> <p>OK. Now let's try defining the structure of our game state. There are three main parts to it: the paddles, the ball, and the score.</p> <pre><code>struct GameState\n{\n    Rectangle right_paddle;\n    Rectangle left_paddle;\n\n    Ball ball;\n\n    int left_score;\n    int right_score;\n};\n</code></pre> <p><code>Rectangle</code> is a struct in Raylib, it has four properties.</p> <pre><code>// Rectangle, 4 components\ntypedef struct Rectangle {\n    float x;                // Rectangle top-left corner position x\n    float y;                // Rectangle top-left corner position y\n    float width;            // Rectangle width\n    float height;           // Rectangle height\n} Rectangle;\n</code></pre> <p>We'll use this struct to represent our paddle, which is simple enough. <code>Ball</code> on the other hand though, is a struct of our own that we haven't defined yet. We will define this struct later. We also have two <code>int</code> variables for our left and right scores. And really, this is all the state that we need for our game.</p> <p>There are three parts to our program: Initialization, then Updating and Drawing in a loop. Let's write these three as functions that take in\u00a0<code>GameState</code>\u00a0as a parameter.</p> <pre><code>void InitGame(GameState&amp; state);\nvoid UpdateGame(GameState&amp; state);\nvoid DrawGame(GameState state);\n</code></pre> <p>Passing by reference</p> <p>Notice that we placed an ampersand (&amp;) in the <code>GameState</code> parameters of <code>InitGame</code> and <code>UpdateGame</code>. This is because we want to pass in the state as a reference. In other words, we want the <code>InitGame</code> and <code>UpdateGame</code> functions to actually modify the state that it receives for good, and not just take it as a copy to do calculations on.</p> <p>Let's rewrite our <code>main</code> function now:</p> <pre><code>int main()\n{\n    GameState state;\n    InitGame(state);\n\n    while (!WindowShouldClose())\n    {\n        UpdateGame(state);\n        DrawGame(state);\n    }\n\n    return 0;\n}\n</code></pre> <p>When we write our code this way, the structure of our game becomes much clearer. In reality, many games/game engines follow a pattern similar to this one. Let's write some of the code for the actual functions themselves now.</p> <pre><code>void InitGame(GameState&amp; state)\n{\n    SetTargetFPS(60);\n    InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, \"Pong\");\n}\n\nvoid UpdateGame(GameState&amp; state)\n{\n}\n\nvoid DrawGame(GameState state)\n{\n    ClearBackground(BLACK);\n    BeginDrawing();\n    EndDrawing();\n}\n</code></pre> <p>Here this is just boilerplate of the same code we had earlier in <code>main</code>, you'll notice the Update function is left empty, this is because we don't yet have any logic for the game yet. We'll change that soon, but now, we have to actually define our <code>Ball</code> struct.</p> <p>The ball is similar to the paddles in the way that we don't need to store the ball's size since it's constant; the size won't ever change (unless we want it to later). One way in which they're different however, is that we actually need to store the ball's velocity. The reason is that the ball's velocity is determined solely by the angle of the paddle it hits, or when the game resets. In both these cases, we can't determine the resulting velocity in any given frame, we can only determine the velocity on the exact frame the collision or reset happens. Since we don't want to reset the velocity every frame, the only way we can tell these things is if we retain the data between frames (from the previous frame to the current one, and so on).</p> <p>When we think about the ball as mutable or variable state, there are only 2 things we have to keep track of: it's position, and it's velocity (movement). We obviously want to know it's position so that we can know the state of the board and the game, but we also want to store the velocity as a variable since we want to keep track of whatever the movement vector is if the ball hit a paddle for example. We don't really have to store the radius as a variable, since it's more of a constant.</p> <pre><code>struct Ball\n{\n    Vector2 position;\n    Vector2 velocity;\n};\n</code></pre> <p>That concludes this segment of us setting up the data, now let's actually write some code for the game's logic.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#initializing-and-drawing","title":"Initializing and Drawing","text":"<p>The first thing that we need to do is initialize the actual games state, and establish how we're gonna draw the state.</p> <p>To initialize the state, we want to do just a couple of things:</p> <ul> <li> <p>Zero out the score</p> </li> <li> <p>Place the ball in the center</p> </li> <li> <p>Set the ball's velocity to move to the right</p> </li> <li> <p>Place both paddles in the center, in their respective sides</p> </li> </ul> <p>Writing this out in code is quite simple enough. First let's just establish some constants that will be useful for us in these calculations. Let's also establish the constants for the paddle's sizes and the ball's radius. For the paddle we're just gonna go for a 10 wide and 150 tall rectangle, and the ball has a radius of 10 pixels.</p> <pre><code>const int SCREEN_TOP = 0;\nconst int SCREEN_BOTTOM = SCREEN_HEIGHT;\nconst int SCREEN_LEFT = 0;\nconst int SCREEN_RIGHT = SCREEN_WIDTH;\nconst Vector2 SCREEN_CENTER = { SCREEN_WIDTH / 2.0, SCREEN_HEIGHT / 2.0 };\n\nconst Vector2 PADDLE_SIZE = { 10, 150 };\nconst float BALL_RADIUS = 10.0f;\n</code></pre> <p>Now let's get to writing the initialization code.</p> <pre><code>const float PADDLE_OFFSET_FROM_EDGE = 40.0f;\n\nvoid InitGame(GameState&amp; state)\n{\n    SetTargetFPS(60);\n    InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, \"Pong\");\n\n    // set the ball position to the center\n    state.ball.position = SCREEN_CENTER;\n    // we want it to move right, we'll place 400 for now\n    state.ball.velocity.x = 400; // placeholder value\n\n    // set the paddles' sizes\n    state.left_paddle.width = PADDLE_SIZE.x;\n    state.left_paddle.height = PADDLE_SIZE.y;\n\n    state.right_paddle.width = PADDLE_SIZE.x;\n    state.right_paddle.height = PADDLE_SIZE.y;\n\n\n    // set the paddles' positions\n    state.left_paddle.x = SCREEN_LEFT + PADDLE_OFFSET_FROM_EDGE;\n    state.left_paddle.y = SCREEN_CENTER.y - PADDLE_SIZE.y * 0.5f;\n\n    state.right_paddle.x = SCREEN_RIGHT - PADDLE_OFFSET_FROM_EDGE - PADDLE_SIZE.x;\n    state.right_paddle.y = SCREEN_CENTER.y - PADDLE_SIZE.y * 0.5f;\n\n    state.left_score = 0;\n    state.right_score = 0;\n}\n</code></pre> <p>We're setting the paddle positions on the x axis by declaring a constant describing how big of a margin we want between the paddles and the edge of the screen, and also making sure to subtract the <code>PADDLE_SIZE.x</code> from the right paddles position taking into account that the origin of the rectangle is in the top-left. For the vertical position we just set it to the <code>SCREEN_CENTER.y</code> subtracting half the <code>PADDLE_SIZE.y</code> to make sure it's properly aligned in the center (keep in mind again that the origin of the rectangle is in the top-left).</p> <p>This initialization code seems good for now, so let's try drawing the state. This is what our <code>DrawGame()</code> function looks like right now.</p> <pre><code>void DrawGame(GameState state)\n{\n    ClearBackground(BLACK);\n    BeginDrawing();\n    EndDrawing();\n}\n</code></pre> <p>Let's add the paddles.</p> <pre><code>    DrawRectangleRec(state.left_paddle, WHITE);\n    DrawRectangleRec(state.right_paddle, WHITE);\n</code></pre> <p><code>DrawRectangleRec</code> is the same as <code>DrawRectangle</code> except it takes in a <code>Rectangle</code> struct as input, instead of 4 variables being manually set.</p> <p>Now the ball. We're going to use the <code>DrawCircle()</code> function which takes in four arguments: <code>centerX, centerY, radius, color</code>.</p> <pre><code>    DrawCircle(state.ball.position.x, state.ball.position.y, BALL_RADIUS, WHITE);\n</code></pre> <p>Finally, let's draw the text of the paddles' score. Here we'll use the <code>DrawText()</code> function which takes in five arguments: <code>text, posX, posY, fontSize, color</code>. For the <code>text</code> parameter, we'll format it the old-school way using the <code>TextFormat()</code> function provided by Raylib.</p> <pre><code>    DrawText(\n        TextFormat(\"%d\", state.left_score), // text\n        SCREEN_CENTER.x - 75, // x position\n        SCREEN_TOP, // y position; top of the screen\n        50, WHITE); // font size, color\n    DrawText(\n        TextFormat(\"%d\", state.right_score), // text\n        SCREEN_CENTER.x + 50, // x position\n        SCREEN_TOP, // y position; top of the screen\n        50, WHITE); // font size, color\n</code></pre> <p>And we're done. By the end, this is what our <code>DrawGame()</code> function should look like:</p> <pre><code>void DrawGame(GameState state)\n{\n    ClearBackground(BLACK);\n    BeginDrawing();\n\n    // Paddles\n    DrawRectangleRec(state.left_paddle, WHITE);\n    DrawRectangleRec(state.right_paddle, WHITE);\n\n    // Ball\n    DrawCircle(state.ball.position.x, state.ball.position.y, BALL_RADIUS, WHITE);\n\n    DrawText(\n        TextFormat(\"%d\", state.left_score), // text\n        SCREEN_CENTER.x - 75, // x position\n        SCREEN_TOP, // y position; top of the screen\n        50, WHITE); // font size, color\n    DrawText(\n        TextFormat(\"%d\", state.right_score), // text\n        SCREEN_CENTER.x + 50, // x position\n        SCREEN_TOP, // y position; top of the screen\n        50, WHITE); // font size, color\n\n    EndDrawing();\n}\n</code></pre> <p>With our state initialized and draw code written, once we build it, this is what it should look like.</p> <p></p> <p>Now we finally have something resembling a game on our hands. Now that we're done with this slightly tedious part we can finally get to the good part: coding the game logic.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#game-logic","title":"Game Logic","text":"<p>When we think about what we need to do for the game logic, there are a number of things we need to implement.</p> <ul> <li> <p>The paddles must move up and down according to player input</p> </li> <li> <p>The ball must also move according to its determined velocity</p> </li> <li> <p>Velocity is determined when it bounces against a paddle\u00a0\u00a0\u00a0</p> </li> <li> <p>It's vertical velocity is also flipped if it hits the top or bottom edge of the screen</p> </li> <li> <p>If a paddle scores a goal, the paddles and the ball must be reset, and the score updated</p> </li> </ul> <p>Simple enough, right? Let's take them on one at a time. First, the paddles movement.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#1-paddle-movement","title":"1. Paddle Movement","text":"<p>We covered movement in the beginning part of this section, so this should be easy enough to implement. We'll use continuous movement here, storing player input into a temporary velocity variable that we'll then use to actually displace the paddles' positions. For the left paddle, W and A will be the keys to move up and down, and for the right, UP arrow and DOWN arrow will move it. Before we do that though, we should declare a constant to describe how fast we want the paddle to move. Remember that this will be a pixels per second metric. Let's set it to the screens height so each paddle can cover the entire side of their goal within 1 second.</p> <pre><code>const float PADDLE_SPEED = (float)SCREEN_HEIGHT;\n</code></pre> <p>Now let's write the movement code. Don't forget to multiply the position displacement by delta time so it moves per second rather than per frame.</p> <pre><code>void UpdateGame(GameState&amp; state)\n{\n    float delta_time = GetFrameTime();\n\n    float right_velocity = 0.0f;\n    if (IsKeyDown(KEY_UP))\n    {\n        right_velocity -= PADDLE_SPEED;\n    }\n    if (IsKeyDown(KEY_DOWN))\n    {\n        right_velocity += PADDLE_SPEED;\n    }\n\n    float left_velocity = 0.0f;\n    if (IsKeyDown(KEY_W))\n    {\n        left_velocity -= PADDLE_SPEED;\n    }\n    if (IsKeyDown(KEY_S))\n    {\n        left_velocity += PADDLE_SPEED;\n    }\n\n    state.left_paddle.y += left_velocity * delta_time;\n    state.right_paddle.y += right_velocity * delta_time;\n}\n</code></pre> <p>Let's build it and see what we get.</p> <p></p> <p>That's that part done. Now let's try to get the ball moving.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#2-balls-movement","title":"2. Ball's movement","text":"<p>First off, let's declare a constant just like we did with the paddles to describe how fast the ball should move horizontally, and replace the placeholder value in the Initialization function. Let's go with 900 for now, which will make it cross the screen in about a second and a half.</p> <pre><code>const float BALL_SPEED = 900.0f;\n\n...\n\n\nvoid InitGame(GameState&amp; state)\n{\n    ...\n    state.ball.velocity.x = BALL_SPEED / 2.0f;\n    ...\n}\n</code></pre> <p>I chose to divide the speed by half in the Initialization, and will also do that when the ball is reset via goal since I think it's better to give players a little time to reposition before the round kicks off.</p> <p>Now let's just apply the movement in the Update function.</p> <pre><code>    state.ball.position.x += state.ball.velocity.x * delta_time;\n    state.ball.position.y += state.ball.velocity.y * delta_time;\n</code></pre> <p>Let's try running now.</p> <p></p> <p>We can see that the ball is in fact moving towards the right. Except, when it reaches the paddle it simply goes through it. The next step for us is to implement basic collision.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#21-collision-detection","title":"2.1 Collision Detection","text":"<p>Raylib already comes with functions for basic collision detection. The one we're interested in is <code>CheckCollisionCircleRec()</code>, which takes in three arguments: <code>center, radius, rec</code>. The <code>rec</code> is of type <code>Rectangle</code>.</p> <p>We already know the ball's position and radius, and the paddles are already of the <code>Rectangle</code> type, right now let's just try and create simple collision detection that flips the horizontal direction of the ball at max speed if it collides with a paddle.</p> <pre><code>    // if collided right paddle, go left\n    if (CheckCollisionCircleRec(\n            state.ball.position,\n            BALL_RADIUS,\n            state.right_paddle))\n    {\n        state.ball.velocity.x = -BALL_SPEED;\n    }\n    // if collided left paddle, go right\n    if (CheckCollisionCircleRec(\n            state.ball.position,\n            BALL_RADIUS,\n            state.left_paddle))\n    {\n        state.ball.velocity.x = BALL_SPEED;\n    }\n</code></pre> <p>Let's run it.</p> <p></p> <p>It works right. However the ball is always going to move in the same direction regardless of the angle of its collision with the paddle. In Pong, the angle of the ball's movement is determined by which part of the paddle it hit. So let's get to work on that now.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#22-reflection","title":"2.2 Reflection","text":"<p>The basic idea behind the reflection of the ball is that the closer the ball collides with the edge, the greater the angle of its velocity.</p> <p></p> <p>One way that we can solve this in code is to make a relation between the vertical (y-axis) velocity of the ball and it's distance from the center of the paddle. We'll take the difference between the ball's position and the paddle's center. Then we'll divide by half the height of the paddle (\\(Paddle\\ Height\\over2\\)), i.e. the distance from the top/bottom edge of the paddle to the center, so that the result is normalized from 0 at the ball's center, and 1 at the edge.</p> <p></p> <p>We'll call this the angle percent, because I don't really have a better name for it. The formula for it is as follows.</p> <p>\\(Angle\\ Percent={{Ball\\ Position\\ Y-Paddle\\ Center\\ Y}\\over {Paddle\\ Half\\ Width}}\\)</p> <p>Once we have this percentage, we can just multiply whatever maximum vertical velocity we want by it. In order to get the paddle's vertical center, we just take the position of its top edge (i.e., it's <code>position.y</code> variable) and add half the height to it.</p> <p>\\(Paddle\\ Center\\ Y=Paddle\\ Top\\ Edge+{Paddle\\ Height\\over2}\\)</p> <p>Let's write this out in code so we can get a better idea of it. Let's declare this maximum vertical velocity that we want as a constant.</p> <pre><code>const float BALL_MAX_VERTICAL_VELOCITY = 180.0f;\n</code></pre> <p>Now let's write out the formula.</p> <pre><code>    if (CheckCollisionCircleRec(\n            state.ball.position,\n            BALL_RADIUS,\n            state.right_paddle))\n    {\n        float paddle_center = state.right_paddle.y + PADDLE_SIZE.y * 0.5f;\n        float angle_percent = (state.ball.y - paddle_center) / (PADDLE_SIZE.y * 0.5f);\n        state.ball.velocity.y = BALL_MAX_VERTICAL_VELOCITY * angle_percent;\n        state.ball.velocity.x = -BALL_SPEED;\n    }\n    if (CheckCollisionCircleRec(\n            state.ball.position,\n            BALL_RADIUS,\n            state.left_paddle))\n    {\n        float paddle_center = state.left_paddley + PADDLE_SIZE.y * 0.5f;\n        float angle_percent = (state.ball.position.y - paddle_center) / (PADDLE_SIZE.y * 0.5f);\n        state.ball.velocity.y = BALL_MAX_VERTICAL_VELOCITY * angle_percent;\n        state.ball.velocity.x = BALL_SPEED;\n    }\n</code></pre> <p>To make the results more reliable, we'll check for collision with a paddle only if the ball is moving in the paddle's direction. This will guarantee that a ball doesn't collide with the same paddle 2 consecutive frames in a row, if it happens to have partially clipped inside it.</p> <pre><code>    if (state.ball.velocity.x &gt; 0) // if moving right\n    {\n        if (CheckCollisionCircleRec(\n                state.ball.position,\n                BALL_RADIUS,\n                state.right_paddle))\n        {\n            float paddle_center = state.right_paddley + PADDLE_SIZE.y * 0.5f;\n            float angle_percent = (state.ball.y - paddle_center) / (PADDLE_SIZE.y * 0.5f);\n            state.ball.velocity.y = BALL_MAX_VERTICAL_VELOCITY * angle_percent;\n            state.ball.velocity.x = -BALL_SPEED;\n        }\n    }\n    if (state.ball.velocity.x &lt; 0) // if moving left\n    {\n        if (CheckCollisionCircleRec(\n                state.ball.position,\n                BALL_RADIUS,\n                state.left_paddle))\n        {\n            float paddle_center = state.left_paddle.y + PADDLE_SIZE.y * 0.5f;\n            float angle_percent = (state.ball.position.y - paddle_center) / (PADDLE_SIZE.y * 0.5f);\n            state.ball.velocity.y = BALL_MAX_VERTICAL_VELOCITY * angle_percent;\n            state.ball.velocity.x = BALL_SPEED;\n        }\n    }\n</code></pre> <p>OK. Let's build and try it out.</p> <p></p> <p>Almost done! Only thing left to do now is to fix the ball not colliding with the top and bottom edges of the screen, which is probably the easiest thing to code here.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#23-ceiling-floor-bounce","title":"2.3 Ceiling / Floor Bounce","text":"<p>In order to get the ball to bounce from the top and bottom edges of the screen, all we need to do is check the top and bottom edge of the circle, and whether or not it's exceeded the respective top and bottom edge of the screen. If it did, we'll simply reverse the vertical velocity to the opposite direction.</p> <p>So if the bottom edge of the circle collided with the bottom edge of the screen, we would take the current vertical velocity <code>ball.velocity.y</code> and force it to be positive. Likewise with the top ceiling. To force the sign of the velocity, we could just multiply by -1, but that might be unreliable since the ball might be touching an edge of the screen for more than 1 frame if it's gone fast enough to go far off-screen. To fix that, we'll only check for a ceiling/floor hit if its moving in that direction.</p> <pre><code>    if (state.ball.velocity.y &gt; 0) // if moving down\n    {\n        // if bottom edge of ball is greater than bottom edge of screen\n        if (state.ball.position.y + BALL_RADIUS &gt; SCREEN_BOTTOM)\n        {\n            state.ball.velocity.y *= -1;\n        }\n    }\n    if (state.ball.velocity.y &lt; 0) // if moving up\n    {\n        // if top edge of ball is greater than top edge of screen\n        if (state.ball.position.y - BALL_RADIUS &lt; SCREEN_TOP)\n        {\n            state.ball.velocity.y *= -1;\n        }\n    }\n</code></pre> <p>Let's build it and run.</p> <p></p> <p>The ball may seem to clip on the edges before bouncing, this is only because the capture doesn't show the full window however. We're done with the ball now. The final step now is to implement the goal and scoring.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#3-scoring-rounds","title":"3. Scoring Rounds","text":"<p>This is also a very simple task. For this one all we have to do is see if the ball's position has touched or exceeded the right or left edge of the screen, no need to calculate for the right and left edge of the ball precisely, since this mostly will not affect gameplay in any serious way. If the ball did in-fact collide with the right or left edge, we will reset the ball's position and velocity, and increment the appropriate paddle's score.</p> <pre><code>    if (state.ball.position.x &gt;= SCREEN_RIGHT)\n    {\n        // ball entered right goal; left scored\n        state.left_score++;\n        state.ball.position = SCREEN_CENTER;\n        state.ball.velocity.y = 0.0f;\n        state.ball.velocity.x = BALL_SPEED * 0.5f;\n    }\n    if (state.ball.position.x &lt;= SCREEN_LEFT)\n    {\n        // ball entered left goal; right scored\n        state.right_score++;\n        state.ball.position = SCREEN_CENTER;\n        state.ball.velocity.y = 0.0f;\n        state.ball.velocity.x = BALL_SPEED * 0.5f;\n    }\n</code></pre> <p>Let's run it.</p> <p></p> <p>It works, and now we're done! We've finally made Pong, in it's entirety.</p>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#tasks","title":"Tasks","text":"<p>There will be a version of the final <code>pong.cpp</code> file available for you, though we recommend stepping through the tutorial yourself and seeing the code get written and why it is the way it is. You are now tasked with modifying this game in three ways. In order of difficulty:</p> <ol> <li> <p>Change the colors of the game, to whichever you prefer</p> </li> <li> <p>Draw a white vertical line in the middle of the board</p> </li> <li> <p>Create two small thin obstacles, one on the left and right, such that if the ball collides with either of them its horizontal velocity <code>ball.velocity.x</code> will be flipped. (Don't worry about the collision detection not being perfect or slightly buggy, that won't be a factor for the task.)</p> </li> </ol> <p></p> <p>Hints:</p> <ul> <li> <p>Look at the Raylib cheatsheet for important functions</p> </li> <li> <p>Use <code>DrawLine()</code> for the line</p> </li> <li> <p>Create two <code>Rectangle</code> structs for the obstacles inside of <code>GameState</code></p> </li> </ul>"},{"location":"Week-1.-Making-Your-First-Game/3-Making-Pong/#conclusion","title":"Conclusion","text":"<p>This concludes our first tutorial on making your first game. Though we won't be using Raylib for the rest of the series, hopefully this tutorial was a good introduction into game programming, and how to think like a game programmer. Although we'll be transitioning to Godot from now on, don't forget that these principles you've learned will still be very important when you're actually programming. The frameworks may be different but the concepts are the same.</p> <p>See you next week!</p>"},{"location":"Week-1.-Making-Your-First-Game/Resources/","title":"Resources","text":"<ul> <li>How To Install GCC/G++ On Windows - YouTube</li> <li>Math for Game Developers - YouTube Series</li> </ul>"}]}